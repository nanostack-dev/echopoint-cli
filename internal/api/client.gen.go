// Package api provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package api

import (
	"bytes"
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for BodyExtractorConfigFormat.
const (
	Json BodyExtractorConfigFormat = "json"
	Raw  BodyExtractorConfigFormat = "raw"
	Text BodyExtractorConfigFormat = "text"
	Xml  BodyExtractorConfigFormat = "xml"
)

// Defines values for CollectionSource.
const (
	CollectionSourceManual  CollectionSource = "manual"
	CollectionSourceOpenapi CollectionSource = "openapi"
)

// Defines values for DefinitionBaseMetadataDifficulty.
const (
	DefinitionBaseMetadataDifficultyAdvanced     DefinitionBaseMetadataDifficulty = "advanced"
	DefinitionBaseMetadataDifficultyBeginner     DefinitionBaseMetadataDifficulty = "beginner"
	DefinitionBaseMetadataDifficultyIntermediate DefinitionBaseMetadataDifficulty = "intermediate"
)

// Defines values for EnvironmentOwnerType.
const (
	EnvironmentOwnerTypeFlow EnvironmentOwnerType = "flow"
)

// Defines values for ExecutionStatus.
const (
	ExecutionStatusCancelled ExecutionStatus = "cancelled"
	ExecutionStatusCompleted ExecutionStatus = "completed"
	ExecutionStatusFailed    ExecutionStatus = "failed"
	ExecutionStatusPending   ExecutionStatus = "pending"
	ExecutionStatusRunning   ExecutionStatus = "running"
)

// Defines values for FlowEdgeType.
const (
	Failure FlowEdgeType = "failure"
	Success FlowEdgeType = "success"
)

// Defines values for HTTPMethod.
const (
	HTTPMethodDELETE  HTTPMethod = "DELETE"
	HTTPMethodGET     HTTPMethod = "GET"
	HTTPMethodHEAD    HTTPMethod = "HEAD"
	HTTPMethodOPTIONS HTTPMethod = "OPTIONS"
	HTTPMethodPATCH   HTTPMethod = "PATCH"
	HTTPMethodPOST    HTTPMethod = "POST"
	HTTPMethodPUT     HTTPMethod = "PUT"
)

// Defines values for HttpMethod.
const (
	HttpMethodDELETE  HttpMethod = "DELETE"
	HttpMethodGET     HttpMethod = "GET"
	HttpMethodHEAD    HttpMethod = "HEAD"
	HttpMethodOPTIONS HttpMethod = "OPTIONS"
	HttpMethodPATCH   HttpMethod = "PATCH"
	HttpMethodPOST    HttpMethod = "POST"
	HttpMethodPUT     HttpMethod = "PUT"
)

// Defines values for NodeDefinitionMetadataDifficulty.
const (
	NodeDefinitionMetadataDifficultyAdvanced     NodeDefinitionMetadataDifficulty = "advanced"
	NodeDefinitionMetadataDifficultyBeginner     NodeDefinitionMetadataDifficulty = "beginner"
	NodeDefinitionMetadataDifficultyIntermediate NodeDefinitionMetadataDifficulty = "intermediate"
)

// Defines values for NodeExecutionResultNodeType.
const (
	NodeExecutionResultNodeTypeDelay   NodeExecutionResultNodeType = "delay"
	NodeExecutionResultNodeTypeRequest NodeExecutionResultNodeType = "request"
)

// Defines values for NodeExecutionStatus.
const (
	NodeExecutionStatusCompleted NodeExecutionStatus = "completed"
	NodeExecutionStatusFailed    NodeExecutionStatus = "failed"
	NodeExecutionStatusPending   NodeExecutionStatus = "pending"
	NodeExecutionStatusRunning   NodeExecutionStatus = "running"
	NodeExecutionStatusSkipped   NodeExecutionStatus = "skipped"
)

// Defines values for NodeType.
const (
	NodeTypeDelay NodeType = "delay"
)

// Defines values for OperationDefinitionCategory.
const (
	Assertion OperationDefinitionCategory = "assertion"
	Extractor OperationDefinitionCategory = "extractor"
)

// Defines values for OperationDefinitionMetadataDifficulty.
const (
	Advanced     OperationDefinitionMetadataDifficulty = "advanced"
	Beginner     OperationDefinitionMetadataDifficulty = "beginner"
	Intermediate OperationDefinitionMetadataDifficulty = "intermediate"
)

// Defines values for OperationType.
const (
	Body       OperationType = "body"
	Boolean    OperationType = "boolean"
	Header     OperationType = "header"
	JsonPath   OperationType = "jsonPath"
	Number     OperationType = "number"
	StatusCode OperationType = "statusCode"
	String     OperationType = "string"
	XmlPath    OperationType = "xmlPath"
)

// Defines values for OperatorType.
const (
	Between            OperatorType = "between"
	Contains           OperatorType = "contains"
	Empty              OperatorType = "empty"
	EndsWith           OperatorType = "endsWith"
	Equals             OperatorType = "equals"
	GreaterThan        OperatorType = "greaterThan"
	GreaterThanOrEqual OperatorType = "greaterThanOrEqual"
	LessThan           OperatorType = "lessThan"
	LessThanOrEqual    OperatorType = "lessThanOrEqual"
	NotContains        OperatorType = "notContains"
	NotEmpty           OperatorType = "notEmpty"
	NotEquals          OperatorType = "notEquals"
	Regex              OperatorType = "regex"
	StartsWith         OperatorType = "startsWith"
)

// Defines values for RequestNodeDataMethod.
const (
	DELETE  RequestNodeDataMethod = "DELETE"
	GET     RequestNodeDataMethod = "GET"
	HEAD    RequestNodeDataMethod = "HEAD"
	OPTIONS RequestNodeDataMethod = "OPTIONS"
	PATCH   RequestNodeDataMethod = "PATCH"
	POST    RequestNodeDataMethod = "POST"
	PUT     RequestNodeDataMethod = "PUT"
)

// Defines values for TriggerType.
const (
	TriggerTypeManual    TriggerType = "manual"
	TriggerTypeScheduled TriggerType = "scheduled"
	TriggerTypeWebhook   TriggerType = "webhook"
)

// ApiError defines model for ApiError.
type ApiError struct {
	// Code A machine-readable error code.
	Code string `json:"code"`

	// Details Additional details about the error (optional).
	Details *map[string]interface{} `json:"details,omitempty"`

	// Field The specific field that caused the error (optional).
	Field *string `json:"field,omitempty"`

	// Message A human-readable error message.
	Message string `json:"message"`
}

// ApiErrorResponse defines model for ApiErrorResponse.
type ApiErrorResponse struct {
	Errors []ApiError `json:"errors"`
}

// BaseFlowNode defines model for BaseFlowNode.
type BaseFlowNode struct {
	// Assertions Validation assertions for the node
	Assertions *[]CompositeAssertion `json:"assertions,omitempty"`

	// DisplayName Human-readable name for the node
	DisplayName string `json:"display_name"`

	// Id Unique identifier for the node
	Id string `json:"id"`

	// Outputs Named outputs extracted from the response/data
	Outputs *[]Output `json:"outputs,omitempty"`

	// Type Type of node
	Type string `json:"type"`
}

// BodyExtractorConfig defines model for BodyExtractorConfig.
type BodyExtractorConfig struct {
	// Format How to format the extracted body
	Format *BodyExtractorConfigFormat `json:"format,omitempty"`
}

// BodyExtractorConfigFormat How to format the extracted body
type BodyExtractorConfigFormat string

// Collection defines model for Collection.
type Collection struct {
	// AuthorId User ID of the collection author
	AuthorId string `json:"author_id"`

	// CreatedAt Timestamp when the collection was created
	CreatedAt time.Time `json:"created_at"`

	// Description Optional description of the collection
	Description *string `json:"description"`

	// Folders Flat array of folders with parent_id references
	Folders []CollectionFolder `json:"folders"`

	// Id Server-generated unique identifier
	Id openapi_types.UUID `json:"id"`

	// Name Human-readable name for the collection
	Name        string               `json:"name"`
	OpenapiSpec *OpenAPISpecMetadata `json:"openapi_spec,omitempty"`

	// Requests Flat array of requests with folder_id references
	Requests []CollectionRequest `json:"requests"`

	// Source Source of the collection
	Source CollectionSource `json:"source"`

	// UpdatedAt Timestamp when the collection was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// CollectionFolder defines model for CollectionFolder.
type CollectionFolder struct {
	// CollectionId Reference to parent collection
	CollectionId openapi_types.UUID `json:"collection_id"`

	// CreatedAt Timestamp when the folder was created
	CreatedAt time.Time `json:"created_at"`

	// Description Optional folder description
	Description *string `json:"description"`

	// Id Server-generated unique identifier
	Id openapi_types.UUID `json:"id"`

	// Name Folder name
	Name string `json:"name"`

	// ParentId Reference to parent folder (null for root folders)
	ParentId *openapi_types.UUID `json:"parent_id"`

	// UpdatedAt Timestamp when the folder was last updated
	UpdatedAt time.Time `json:"updated_at"`
}

// CollectionListResponse defines model for CollectionListResponse.
type CollectionListResponse struct {
	// Count The number of items returned in this response.
	Count int          `json:"count"`
	Items []Collection `json:"items"`

	// Total Total number of matching items.
	Total int64 `json:"total"`
}

// CollectionRequest defines model for CollectionRequest.
type CollectionRequest struct {
	// Body Request body (any JSON structure)
	Body *map[string]interface{} `json:"body"`

	// CollectionId Reference to parent collection
	CollectionId openapi_types.UUID `json:"collection_id"`

	// CreatedAt Timestamp when the request was created
	CreatedAt time.Time `json:"created_at"`

	// Description Optional request description
	Description *string `json:"description"`

	// FolderId Reference to parent folder (null for root level)
	FolderId *openapi_types.UUID `json:"folder_id"`

	// Headers HTTP headers for the request
	Headers *map[string]string `json:"headers"`

	// Id Server-generated unique identifier
	Id openapi_types.UUID `json:"id"`

	// Method HTTP method for requests
	Method HTTPMethod `json:"method"`

	// Name Request name
	Name string `json:"name"`

	// Timeout Request timeout in milliseconds
	Timeout *int `json:"timeout"`

	// UpdatedAt Timestamp when the request was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// Url Request URL
	Url string `json:"url"`
}

// CollectionSource Source of the collection
type CollectionSource string

// CompositeAssertion defines model for CompositeAssertion.
type CompositeAssertion struct {
	// ExtractorData Configuration for the extractor
	ExtractorData map[string]interface{} `json:"extractor_data"`

	// ExtractorType Type of extractor to use for data extraction
	ExtractorType ExtractorType `json:"extractor_type"`

	// OperatorData Configuration for the operator
	OperatorData map[string]interface{} `json:"operator_data"`

	// OperatorType Operator to apply in assertions
	OperatorType OperatorType `json:"operator_type"`
}

// CreateCollectionRequest defines model for CreateCollectionRequest.
type CreateCollectionRequest struct {
	// Description Optional description
	Description *string `json:"description"`

	// Name Collection name
	Name string `json:"name"`

	// Source Source of the collection
	Source *CollectionSource `json:"source,omitempty"`
}

// CreateFlowEnvironmentRequest Request to create or update flow environment
type CreateFlowEnvironmentRequest struct {
	// Variables Environment variables to set
	Variables map[string]string `json:"variables"`
}

// CreateFlowRequest defines model for CreateFlowRequest.
type CreateFlowRequest struct {
	// AutoLayout Recompute node positions on create using backend layout.
	AutoLayout *bool `json:"auto_layout,omitempty"`

	// Description Optional description of the flow.
	Description    *string        `json:"description"`
	FlowDefinition FlowDefinition `json:"flow_definition"`

	// Metadata Frontend-specific metadata including UI layout information.
	Metadata *CreateFlowRequest_Metadata `json:"metadata,omitempty"`

	// Name Human-readable name for the flow.
	Name string `json:"name"`

	// Version Version identifier for the flow.
	Version *string `json:"version,omitempty"`
}

// CreateFlowRequest_Metadata Frontend-specific metadata including UI layout information.
type CreateFlowRequest_Metadata struct {
	// NodePositions Map of node IDs to their x,y positions in the editor.
	NodePositions *map[string]struct {
		X *float32 `json:"x,omitempty"`
		Y *float32 `json:"y,omitempty"`
	} `json:"node_positions,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// CreateFolderRequest defines model for CreateFolderRequest.
type CreateFolderRequest struct {
	// Description Optional folder description
	Description *string `json:"description"`

	// Name Folder name
	Name string `json:"name"`

	// ParentId Parent folder ID (null for root level)
	ParentId *openapi_types.UUID `json:"parent_id"`
}

// CreateRequestRequest defines model for CreateRequestRequest.
type CreateRequestRequest struct {
	// Body Request body (any JSON structure)
	Body *map[string]interface{} `json:"body"`

	// Description Optional request description
	Description *string `json:"description"`

	// FolderId Parent folder ID (null for collection root)
	FolderId *openapi_types.UUID `json:"folder_id"`

	// Headers HTTP headers
	Headers *map[string]string `json:"headers"`

	// Method HTTP method for requests
	Method HTTPMethod `json:"method"`

	// Name Request name
	Name string `json:"name"`

	// Timeout Request timeout in milliseconds
	Timeout *int `json:"timeout"`

	// Url Request URL
	Url string `json:"url"`
}

// CreateWebhookRequest defines model for CreateWebhookRequest.
type CreateWebhookRequest struct {
	// Name Human-readable name for the webhook endpoint.
	Name string `json:"name"`
}

// DefinitionBase defines model for DefinitionBase.
type DefinitionBase struct {
	// Description Description of what this does
	Description *string `json:"description"`

	// Metadata Additional metadata for UI or categorization
	Metadata *DefinitionBase_Metadata `json:"metadata,omitempty"`

	// Name Human-readable name
	Name string `json:"name"`

	// UsageExamples Example use cases
	UsageExamples *[]string `json:"usage_examples,omitempty"`
}

// DefinitionBaseMetadataDifficulty defines model for DefinitionBase.Metadata.Difficulty.
type DefinitionBaseMetadataDifficulty string

// DefinitionBase_Metadata Additional metadata for UI or categorization
type DefinitionBase_Metadata struct {
	Category             *string                           `json:"category,omitempty"`
	Difficulty           *DefinitionBaseMetadataDifficulty `json:"difficulty,omitempty"`
	Tags                 *[]string                         `json:"tags,omitempty"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}

// DelayFlowNode defines model for DelayFlowNode.
type DelayFlowNode struct {
	// Assertions Validation assertions for the node
	Assertions *[]CompositeAssertion `json:"assertions,omitempty"`
	Data       DelayNodeData         `json:"data"`

	// DisplayName Human-readable name for the node
	DisplayName string `json:"display_name"`

	// Id Unique identifier for the node
	Id string `json:"id"`

	// Outputs Named outputs extracted from the response/data
	Outputs *[]Output `json:"outputs,omitempty"`
	Type    string    `json:"type"`
}

// DelayNodeData defines model for DelayNodeData.
type DelayNodeData struct {
	// Duration Delay duration in milliseconds
	Duration int `json:"duration"`
}

// Environment defines model for Environment.
type Environment struct {
	// AuthorId User ID of the environment creator
	AuthorId string `json:"author_id"`

	// CreatedAt When the environment was created
	CreatedAt time.Time `json:"created_at"`

	// Id Server-generated unique identifier
	Id openapi_types.UUID `json:"id"`

	// OwnerId The owner (flow, organization, workspace, etc.)
	OwnerId openapi_types.UUID `json:"owner_id"`

	// OwnerType Type of owner
	OwnerType EnvironmentOwnerType `json:"owner_type"`

	// UpdatedAt When the environment was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// Variables Environment variables as key-value pairs
	Variables map[string]EnvironmentVariable `json:"variables"`
}

// EnvironmentOwnerType Type of owner
type EnvironmentOwnerType string

// EnvironmentVariable defines model for EnvironmentVariable.
type EnvironmentVariable struct {
	// AuthorId User ID who created/updated this variable
	AuthorId string `json:"author_id"`

	// CreatedAt When the variable was created
	CreatedAt time.Time `json:"created_at"`

	// UpdatedAt When the variable was last updated
	UpdatedAt time.Time `json:"updated_at"`

	// Value The variable value
	Value string `json:"value"`
}

// ExecutionStatus Status of a flow execution
type ExecutionStatus string

// ExportedFlow defines model for ExportedFlow.
type ExportedFlow struct {
	// Description Description of what the flow does
	Description *string `json:"description,omitempty"`

	// Edges Connections between nodes
	Edges []FlowEdge `json:"edges"`

	// InitialInputs Initial input variables for the flow (from environment)
	InitialInputs map[string]interface{} `json:"initialInputs"`

	// Name Name of the flow
	Name string `json:"name"`

	// Nodes List of nodes in the flow
	Nodes []FlowNode `json:"nodes"`

	// Version Flow definition version
	Version string `json:"version"`
}

// ExtractorType Type of extractor to use for data extraction
type ExtractorType string

// Flow defines model for Flow.
type Flow struct {
	// AuthorId User ID of the flow author.
	AuthorId string `json:"author_id"`

	// CreatedAt Timestamp when the flow was created.
	CreatedAt time.Time `json:"created_at"`

	// Description Optional description of what the flow does.
	Description    *string        `json:"description"`
	FlowDefinition FlowDefinition `json:"flow_definition"`

	// Id Server-generated unique identifier for the flow.
	Id openapi_types.UUID `json:"id"`

	// Metadata Frontend-specific metadata including UI layout information.
	Metadata Flow_Metadata `json:"metadata"`

	// Name Human-readable name for the flow.
	Name string `json:"name"`

	// UpdatedAt Timestamp when the flow was last updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Version Version identifier for the flow.
	Version string `json:"version"`
}

// Flow_Metadata Frontend-specific metadata including UI layout information.
type Flow_Metadata struct {
	// NodePositions Map of node IDs to their x,y positions in the editor.
	NodePositions *map[string]struct {
		X *float32 `json:"x,omitempty"`
		Y *float32 `json:"y,omitempty"`
	} `json:"node_positions,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// FlowDefinition defines model for FlowDefinition.
type FlowDefinition struct {
	// Description Description of what the flow does
	Description *string `json:"description,omitempty"`

	// Edges Connections between nodes
	Edges []FlowEdge `json:"edges"`

	// Name Name of the flow
	Name string `json:"name"`

	// Nodes List of nodes in the flow
	Nodes []FlowNode `json:"nodes"`

	// Version Flow definition version
	Version string `json:"version"`
}

// FlowEdge defines model for FlowEdge.
type FlowEdge struct {
	// Id Unique identifier for the edge
	Id string `json:"id"`

	// Source ID of the source node
	Source string `json:"source"`

	// Target ID of the target node
	Target string `json:"target"`

	// Type Condition for following this edge
	Type FlowEdgeType `json:"type"`
}

// FlowEdgeType Condition for following this edge
type FlowEdgeType string

// FlowExecution defines model for FlowExecution.
type FlowExecution struct {
	// AuthorId User ID who triggered the execution
	AuthorId string `json:"author_id"`

	// CompletedAt When the execution completed (if finished)
	CompletedAt *time.Time `json:"completed_at"`
	CreatedAt   time.Time  `json:"created_at"`

	// ErrorCode Error code if execution failed
	ErrorCode *string `json:"error_code"`

	// ErrorMessage Error message if execution failed
	ErrorMessage *string `json:"error_message"`

	// FlowId ID of the flow that was executed
	FlowId       openapi_types.UUID `json:"flow_id"`
	FlowSnapshot FlowDefinition     `json:"flow_snapshot"`

	// Id Unique identifier for the execution
	Id openapi_types.UUID `json:"id"`

	// StartedAt When the execution started
	StartedAt time.Time `json:"started_at"`

	// Status Status of a flow execution
	Status ExecutionStatus `json:"status"`

	// TriggerMetadata Additional metadata about the trigger
	TriggerMetadata *map[string]interface{} `json:"trigger_metadata"`

	// TriggerType How a flow execution was triggered
	TriggerType *TriggerType `json:"trigger_type,omitempty"`
	UpdatedAt   time.Time    `json:"updated_at"`
}

// FlowExecutionListResponse defines model for FlowExecutionListResponse.
type FlowExecutionListResponse struct {
	// Count The number of items returned in this response.
	Count int             `json:"count"`
	Items []FlowExecution `json:"items"`

	// Total Total number of matching items.
	Total int64 `json:"total"`
}

// FlowListResponse defines model for FlowListResponse.
type FlowListResponse struct {
	// Count The number of items returned in this response.
	Count int    `json:"count"`
	Items []Flow `json:"items"`

	// Total Total number of matching items.
	Total int64 `json:"total"`
}

// FlowNode defines model for FlowNode.
type FlowNode struct {
	union json.RawMessage
}

// HTTPMethod HTTP method for requests
type HTTPMethod string

// HeaderExtractorConfig defines model for HeaderExtractorConfig.
type HeaderExtractorConfig struct {
	// DefaultValue Default value if header not found
	DefaultValue *string `json:"default_value"`

	// HeaderName HTTP header name (case-sensitive)
	HeaderName string `json:"header_name"`
}

// HttpMethod HTTP method
type HttpMethod string

// ImportOpenAPIRequest defines model for ImportOpenAPIRequest.
type ImportOpenAPIRequest struct {
	Options *OpenAPIImportOptions `json:"options,omitempty"`

	// Spec OpenAPI spec as JSON object
	Spec map[string]interface{} `json:"spec"`
}

// JSONPathExtractorConfig defines model for JSONPathExtractorConfig.
type JSONPathExtractorConfig struct {
	// DefaultValue Default value if path not found
	DefaultValue interface{} `json:"default_value,omitempty"`

	// Path JSONPath expression (RFC 9535)
	Path string `json:"path"`
}

// MethodDistribution defines model for MethodDistribution.
type MethodDistribution struct {
	// Count Number of requests using this method.
	Count int `json:"count"`

	// Method HTTP method.
	Method string `json:"method"`

	// Percentage Percentage of total requests (0.0 to 1.0).
	Percentage float32 `json:"percentage"`
}

// MethodDistributionResponse defines model for MethodDistributionResponse.
type MethodDistributionResponse struct {
	// From Start datetime for the analytics data.
	From  time.Time            `json:"from"`
	Items []MethodDistribution `json:"items"`

	// To End datetime for the analytics data.
	To time.Time `json:"to"`
}

// NodeDefinition defines model for NodeDefinition.
type NodeDefinition struct {
	// Config Configuration specific to the node type
	Config map[string]interface{} `json:"config"`

	// Description Description of what this does
	Description *string `json:"description"`

	// Metadata Additional metadata for UI or categorization
	Metadata *NodeDefinition_Metadata `json:"metadata,omitempty"`

	// Name Human-readable name
	Name string `json:"name"`

	// Type Type of special node for flow control
	Type NodeType `json:"type"`

	// UsageExamples Example use cases
	UsageExamples *[]string `json:"usage_examples,omitempty"`
}

// NodeDefinitionMetadataDifficulty defines model for NodeDefinition.Metadata.Difficulty.
type NodeDefinitionMetadataDifficulty string

// NodeDefinition_Metadata Additional metadata for UI or categorization
type NodeDefinition_Metadata struct {
	Category             *string                           `json:"category,omitempty"`
	Difficulty           *NodeDefinitionMetadataDifficulty `json:"difficulty,omitempty"`
	Tags                 *[]string                         `json:"tags,omitempty"`
	AdditionalProperties map[string]interface{}            `json:"-"`
}

// NodeExecutionHistoryResponse defines model for NodeExecutionHistoryResponse.
type NodeExecutionHistoryResponse struct {
	// Count The number of items returned in this response.
	Count int                   `json:"count"`
	Items []NodeExecutionResult `json:"items"`

	// Total Total number of matching items.
	Total int64 `json:"total"`
}

// NodeExecutionResult Node execution result with hybrid design: single source of truth (result) + promoted columns.
// The `result` field contains the complete polymorphic result from the flow engine.
type NodeExecutionResult struct {
	CompletedAt *time.Time `json:"completed_at"`
	CreatedAt   time.Time  `json:"created_at"`

	// DisplayName Human-readable name for the node
	DisplayName string `json:"display_name"`

	// DurationMs Duration in milliseconds (promoted from result)
	DurationMs *int `json:"duration_ms"`

	// ErrorCode System-level error code
	ErrorCode *string `json:"error_code"`

	// ErrorMessage System-level error (orchestration failures)
	ErrorMessage *string `json:"error_message"`

	// ExecutionId ID of the parent execution
	ExecutionId openapi_types.UUID `json:"execution_id"`

	// FlowId ID of the flow
	FlowId openapi_types.UUID `json:"flow_id"`

	// HasErrors Fast flag for filtering failures (promoted from result)
	HasErrors *bool `json:"has_errors"`

	// Id Unique identifier for the node result
	Id openapi_types.UUID `json:"id"`

	// NodeId ID of the node (from flow definition)
	NodeId string `json:"node_id"`

	// NodeType Type of node (promoted from result)
	NodeType NodeExecutionResultNodeType `json:"node_type"`

	// Result Complete polymorphic result from flow engine.
	// Contains RequestExecutionResult or DelayExecutionResult based on node_type.
	// Includes all data: request/response, assertions, extracted outputs, etc.
	Result    *map[string]interface{} `json:"result"`
	StartedAt *time.Time              `json:"started_at"`

	// Status Status of a single node execution
	Status    NodeExecutionStatus `json:"status"`
	UpdatedAt time.Time           `json:"updated_at"`
}

// NodeExecutionResultNodeType Type of node (promoted from result)
type NodeExecutionResultNodeType string

// NodeExecutionStatus Status of a single node execution
type NodeExecutionStatus string

// NodeType Type of special node for flow control
type NodeType string

// OpenAPIImportOptions defines model for OpenAPIImportOptions.
type OpenAPIImportOptions struct {
	// CollectionName Name for the imported collection
	CollectionName *string `json:"collection_name,omitempty"`

	// TagsAsFolders Whether to use OpenAPI tags as folder structure
	TagsAsFolders *bool `json:"tags_as_folders,omitempty"`
}

// OpenAPIImportResult defines model for OpenAPIImportResult.
type OpenAPIImportResult struct {
	Collection Collection `json:"collection"`

	// FoldersCreated Number of folders created from tags
	FoldersCreated *int `json:"folders_created,omitempty"`

	// RequestsCreated Number of requests created from the spec
	RequestsCreated int `json:"requests_created"`

	// Warnings List of warnings from the import process
	Warnings *[]string `json:"warnings,omitempty"`
}

// OpenAPISpecMetadata defines model for OpenAPISpecMetadata.
type OpenAPISpecMetadata struct {
	// ImportedAt Timestamp when the spec was imported
	ImportedAt time.Time `json:"imported_at"`

	// OriginalUrl Original URL where the spec was imported from
	OriginalUrl *string `json:"original_url"`

	// Version Version of the OpenAPI spec
	Version string `json:"version"`
}

// OperationDefinition defines model for OperationDefinition.
type OperationDefinition struct {
	// Category Category of operation
	Category OperationDefinitionCategory `json:"category"`

	// Config Configuration specific to the operation type
	Config *OperationDefinition_Config `json:"config,omitempty"`

	// Description Description of what this does
	Description *string `json:"description"`

	// Metadata Additional metadata for UI or categorization
	Metadata *OperationDefinition_Metadata `json:"metadata,omitempty"`

	// Name Human-readable name
	Name string `json:"name"`

	// Type Type of operation for data extraction or validation
	Type OperationType `json:"type"`

	// UsageExamples Example use cases
	UsageExamples *[]string `json:"usage_examples,omitempty"`
}

// OperationDefinitionCategory Category of operation
type OperationDefinitionCategory string

// OperationDefinition_Config Configuration specific to the operation type
type OperationDefinition_Config struct {
	AdditionalProperties map[string]interface{} `json:"-"`
	union                json.RawMessage
}

// OperationDefinitionMetadataDifficulty defines model for OperationDefinition.Metadata.Difficulty.
type OperationDefinitionMetadataDifficulty string

// OperationDefinition_Metadata Additional metadata for UI or categorization
type OperationDefinition_Metadata struct {
	Category             *string                                `json:"category,omitempty"`
	Difficulty           *OperationDefinitionMetadataDifficulty `json:"difficulty,omitempty"`
	Tags                 *[]string                              `json:"tags,omitempty"`
	AdditionalProperties map[string]interface{}                 `json:"-"`
}

// OperationType Type of operation for data extraction or validation
type OperationType string

// OperatorType Operator to apply in assertions
type OperatorType string

// Output defines model for Output.
type Output struct {
	// Extractor Extractor configuration that defines how to extract data from the response
	Extractor struct {
		// HeaderName Header name to extract (used by header extractor)
		HeaderName *string `json:"header_name,omitempty"`

		// Path Path for extraction (used by jsonPath, xmlPath, header extractors)
		Path *string `json:"path,omitempty"`

		// Type Type of extractor to use for data extraction
		Type ExtractorType `json:"type"`
	} `json:"extractor"`

	// Name Name of the output for reference by downstream nodes
	Name string `json:"name"`
}

// PagedListResponse defines model for PagedListResponse.
type PagedListResponse struct {
	// Count The number of items returned in this response.
	Count int `json:"count"`

	// Total Total number of matching items.
	Total int64 `json:"total"`
}

// PaginationRequest defines model for PaginationRequest.
type PaginationRequest struct {
	Limit  *int32 `json:"limit,omitempty"`
	Offset *int32 `json:"offset,omitempty"`
}

// RequestFlowNode defines model for RequestFlowNode.
type RequestFlowNode struct {
	// Assertions Validation assertions for the node
	Assertions *[]CompositeAssertion `json:"assertions,omitempty"`
	Data       RequestNodeData       `json:"data"`

	// DisplayName Human-readable name for the node
	DisplayName string `json:"display_name"`

	// Id Unique identifier for the node
	Id string `json:"id"`

	// Outputs Named outputs extracted from the response/data
	Outputs *[]Output `json:"outputs,omitempty"`
	Type    string    `json:"type"`
}

// RequestNodeData defines model for RequestNodeData.
type RequestNodeData struct {
	// Body Request body (can be any JSON structure). Supports variable substitution.
	// Any string values within the body can contain template variables.
	Body interface{} `json:"body,omitempty"`

	// Headers HTTP headers. Supports the same variable substitution as URL.
	// Headers can reference both initial inputs and previous node outputs.
	Headers *map[string]string `json:"headers,omitempty"`

	// Method HTTP method
	Method RequestNodeDataMethod `json:"method"`

	// QueryParams Query parameters. Supports variable substitution.
	// All keys and values can contain template variables.
	QueryParams *map[string]interface{} `json:"query_params,omitempty"`

	// Timeout Request timeout in milliseconds
	Timeout *int `json:"timeout,omitempty"`

	// Url Full URL for the request. Supports variable substitution using template syntax.
	// - Initial variables: {{variableName}} (e.g., {{apiUrl}})
	// - Node outputs: {{nodeId.outputKey}} (e.g., {{create-user.userId}})
	Url string `json:"url"`
}

// RequestNodeDataMethod HTTP method
type RequestNodeDataMethod string

// RequestVolumePoint defines model for RequestVolumePoint.
type RequestVolumePoint struct {
	RequestCount int       `json:"request_count"`
	Timestamp    time.Time `json:"timestamp"`
}

// RequestVolumesResponse defines model for RequestVolumesResponse.
type RequestVolumesResponse struct {
	// From Start datetime for the analytics data.
	From       time.Time            `json:"from"`
	TimeSeries []RequestVolumePoint `json:"time_series"`

	// To End datetime for the analytics data.
	To time.Time `json:"to"`
}

// SearchRequest Generic search request template
type SearchRequest struct {
	// FullTextSearch Full-text search term to match against searchable fields.
	FullTextSearch *string            `json:"full_text_search,omitempty"`
	Pagination     *PaginationRequest `json:"pagination,omitempty"`
	SortDirection  *SortDirection     `json:"sort_direction,omitempty"`
}

// SortDirection defines model for SortDirection.
type SortDirection string

// StatusCodeExtractorConfig Status code extractor requires no configuration
type StatusCodeExtractorConfig = map[string]interface{}

// TriggerType How a flow execution was triggered
type TriggerType string

// UpdateCollectionRequest defines model for UpdateCollectionRequest.
type UpdateCollectionRequest struct {
	// Description Optional description
	Description *string `json:"description"`

	// Name Collection name
	Name *string `json:"name,omitempty"`
}

// UpdateFlowEnvironmentRequest Request to update flow environment
type UpdateFlowEnvironmentRequest struct {
	// Variables Environment variables to update
	Variables map[string]string `json:"variables"`
}

// UpdateFlowRequest defines model for UpdateFlowRequest.
type UpdateFlowRequest struct {
	// AutoLayout Recompute node positions on update using backend layout.
	AutoLayout *bool `json:"auto_layout,omitempty"`

	// Description Optional description of the flow.
	Description    *string         `json:"description"`
	FlowDefinition *FlowDefinition `json:"flow_definition,omitempty"`

	// Metadata Frontend-specific metadata including UI layout information.
	Metadata *UpdateFlowRequest_Metadata `json:"metadata,omitempty"`

	// Name Human-readable name for the flow.
	Name *string `json:"name,omitempty"`

	// Version Version identifier for the flow.
	Version *string `json:"version,omitempty"`
}

// UpdateFlowRequest_Metadata Frontend-specific metadata including UI layout information.
type UpdateFlowRequest_Metadata struct {
	// NodePositions Map of node IDs to their x,y positions in the editor.
	NodePositions *map[string]struct {
		X *float32 `json:"x,omitempty"`
		Y *float32 `json:"y,omitempty"`
	} `json:"node_positions,omitempty"`
	AdditionalProperties map[string]interface{} `json:"-"`
}

// UpdateFolderRequest defines model for UpdateFolderRequest.
type UpdateFolderRequest struct {
	// Description Optional folder description
	Description *string `json:"description"`

	// Name Folder name
	Name *string `json:"name,omitempty"`

	// ParentId Parent folder ID (null to move to root)
	ParentId *openapi_types.UUID `json:"parent_id"`
}

// UpdateRequestRequest defines model for UpdateRequestRequest.
type UpdateRequestRequest struct {
	// Body Request body (any JSON structure)
	Body *map[string]interface{} `json:"body"`

	// Description Optional request description
	Description *string `json:"description"`

	// FolderId Parent folder ID
	FolderId *openapi_types.UUID `json:"folder_id"`

	// Headers HTTP headers
	Headers *map[string]string `json:"headers"`

	// Method HTTP method for requests
	Method *HTTPMethod `json:"method,omitempty"`

	// Name Request name
	Name *string `json:"name,omitempty"`

	// Timeout Request timeout in milliseconds
	Timeout *int `json:"timeout"`

	// Url Request URL
	Url *string `json:"url,omitempty"`
}

// Webhook defines model for Webhook.
type Webhook struct {
	// CreatedAt Timestamp when the webhook endpoint was created.
	CreatedAt time.Time `json:"created_at"`

	// Id Unique identifier for the webhook endpoint.
	Id string `json:"id"`

	// Name Human-readable name for the webhook endpoint.
	Name string `json:"name"`

	// RequestCount Total number of requests received by this webhook endpoint.
	RequestCount int `json:"request_count"`

	// UpdatedAt Timestamp when the webhook endpoint was last updated.
	UpdatedAt time.Time `json:"updated_at"`

	// Url The URL where webhook requests are received.
	Url string `json:"url"`
}

// WebhookRequestFilter defines model for WebhookRequestFilter.
type WebhookRequestFilter struct {
	// HasBody Filter by presence of request body.
	HasBody *bool `json:"has_body,omitempty"`

	// HasQueryParams Filter by presence of query parameters.
	HasQueryParams *bool `json:"has_query_params,omitempty"`

	// Ids Filter by specific webhook request IDs.
	Ids []string `json:"ids,omitempty"`

	// IpAddresses Filter by IP addresses.
	IpAddresses []string `json:"ip_addresses,omitempty"`

	// Methods Filter by HTTP methods.
	Methods []HttpMethod `json:"methods,omitempty"`

	// Since Include requests received at or after this timestamp.
	Since *time.Time `json:"since,omitempty"`

	// Until Include requests received at or before this timestamp.
	Until *time.Time `json:"until,omitempty"`
}

// WebhookRequestListResponse defines model for WebhookRequestListResponse.
type WebhookRequestListResponse struct {
	// Count The number of items returned in this response.
	Count int                      `json:"count"`
	Items []WebhookRequestResponse `json:"items"`

	// Total Total number of matching items.
	Total int64 `json:"total"`
}

// WebhookRequestResponse defines model for WebhookRequestResponse.
type WebhookRequestResponse struct {
	// Body Raw request body content.
	Body *string `json:"body"`

	// ContentType Content-Type header value.
	ContentType *string `json:"content_type"`

	// Headers HTTP headers received with the request.
	Headers map[string]string `json:"headers"`

	// Id Unique identifier for the webhook request.
	Id string `json:"id"`

	// IpAddress IP address of the request sender.
	IpAddress string `json:"ip_address"`

	// Method HTTP method
	Method HttpMethod `json:"method"`

	// QueryParams Query parameters received with the request.
	QueryParams map[string]string `json:"query_params"`

	// ReceivedAt Timestamp when the request was received.
	ReceivedAt time.Time `json:"received_at"`

	// UserAgent User-Agent header value.
	UserAgent *string `json:"user_agent"`

	// WebhookId ID of the webhook endpoint that received this request.
	WebhookId string `json:"webhook_id"`
}

// WebhookRequestSearchRequest defines model for WebhookRequestSearchRequest.
type WebhookRequestSearchRequest struct {
	Filter *WebhookRequestFilter `json:"filter,omitempty"`

	// FullTextSearch Full-text search term to match against searchable fields.
	FullTextSearch *string            `json:"full_text_search,omitempty"`
	Pagination     *PaginationRequest `json:"pagination,omitempty"`

	// SortBy Field to sort by
	SortBy        *string        `json:"sort_by,omitempty"`
	SortDirection *SortDirection `json:"sort_direction,omitempty"`
}

// WebhookResponse defines model for WebhookResponse.
type WebhookResponse struct {
	// Message Success message confirming webhook receipt.
	Message string `json:"message"`

	// ReceivedAt Timestamp when the webhook was received.
	ReceivedAt time.Time `json:"received_at"`

	// RequestId Unique identifier for this webhook request.
	RequestId string `json:"request_id"`
}

// XMLPathExtractorConfig defines model for XMLPathExtractorConfig.
type XMLPathExtractorConfig struct {
	// DefaultValue Default value if path not found
	DefaultValue interface{} `json:"default_value,omitempty"`

	// Path XPath expression
	Path string `json:"path"`
}

// LimitParameter defines model for LimitParameter.
type LimitParameter = int32

// OffsetParameter defines model for OffsetParameter.
type OffsetParameter = int32

// WebhookIdParameter defines model for WebhookIdParameter.
type WebhookIdParameter = string

// BadRequest defines model for BadRequest.
type BadRequest = ApiErrorResponse

// Conflict defines model for Conflict.
type Conflict = ApiErrorResponse

// InternalServerError defines model for InternalServerError.
type InternalServerError = ApiErrorResponse

// NotFound defines model for NotFound.
type NotFound = ApiErrorResponse

// Unauthorized defines model for Unauthorized.
type Unauthorized = ApiErrorResponse

// ListCollectionsParams defines parameters for ListCollections.
type ListCollectionsParams struct {
	// Limit Maximum number of items per page.
	Limit LimitParameter `form:"limit" json:"limit"`

	// Offset Number of items to skip.
	Offset OffsetParameter `form:"offset" json:"offset"`
}

// ListFlowsParams defines parameters for ListFlows.
type ListFlowsParams struct {
	// Limit Maximum number of items per page.
	Limit LimitParameter `form:"limit" json:"limit"`

	// Offset Number of items to skip.
	Offset OffsetParameter `form:"offset" json:"offset"`
}

// GetNodeExecutionHistoryParams defines parameters for GetNodeExecutionHistory.
type GetNodeExecutionHistoryParams struct {
	// Limit Maximum number of items per page.
	Limit LimitParameter `form:"limit" json:"limit"`

	// Offset Number of items to skip.
	Offset OffsetParameter `form:"offset" json:"offset"`
}

// ListFlowExecutionsParams defines parameters for ListFlowExecutions.
type ListFlowExecutionsParams struct {
	// Limit Maximum number of items per page.
	Limit LimitParameter `form:"limit" json:"limit"`

	// Offset Number of items to skip.
	Offset OffsetParameter `form:"offset" json:"offset"`
}

// GetWebhookMethodDistributionParams defines parameters for GetWebhookMethodDistribution.
type GetWebhookMethodDistributionParams struct {
	// From Start datetime for analytics data (ISO 8601 format).
	From time.Time `form:"from" json:"from"`

	// To End datetime for analytics data (ISO 8601 format).
	To time.Time `form:"to" json:"to"`
}

// GetWebhookRequestVolumesParams defines parameters for GetWebhookRequestVolumes.
type GetWebhookRequestVolumesParams struct {
	// From Start datetime for analytics data (ISO 8601 format).
	From time.Time `form:"from" json:"from"`

	// To End datetime for analytics data (ISO 8601 format).
	To time.Time `form:"to" json:"to"`
}

// StreamWebhookRequestsParams defines parameters for StreamWebhookRequests.
type StreamWebhookRequestsParams struct {
	Limit int32 `form:"limit" json:"limit"`
}

// CreateCollectionJSONRequestBody defines body for CreateCollection for application/json ContentType.
type CreateCollectionJSONRequestBody = CreateCollectionRequest

// ImportFromOpenAPIJSONRequestBody defines body for ImportFromOpenAPI for application/json ContentType.
type ImportFromOpenAPIJSONRequestBody = ImportOpenAPIRequest

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody = UpdateFolderRequest

// UpdateRequestJSONRequestBody defines body for UpdateRequest for application/json ContentType.
type UpdateRequestJSONRequestBody = UpdateRequestRequest

// UpdateCollectionJSONRequestBody defines body for UpdateCollection for application/json ContentType.
type UpdateCollectionJSONRequestBody = UpdateCollectionRequest

// AddFolderJSONRequestBody defines body for AddFolder for application/json ContentType.
type AddFolderJSONRequestBody = CreateFolderRequest

// AddRequestJSONRequestBody defines body for AddRequest for application/json ContentType.
type AddRequestJSONRequestBody = CreateRequestRequest

// CreateFlowJSONRequestBody defines body for CreateFlow for application/json ContentType.
type CreateFlowJSONRequestBody = CreateFlowRequest

// UpdateFlowJSONRequestBody defines body for UpdateFlow for application/json ContentType.
type UpdateFlowJSONRequestBody = UpdateFlowRequest

// CreateOrUpdateFlowEnvironmentJSONRequestBody defines body for CreateOrUpdateFlowEnvironment for application/json ContentType.
type CreateOrUpdateFlowEnvironmentJSONRequestBody = CreateFlowEnvironmentRequest

// UpdateFlowEnvironmentJSONRequestBody defines body for UpdateFlowEnvironment for application/json ContentType.
type UpdateFlowEnvironmentJSONRequestBody = UpdateFlowEnvironmentRequest

// CreateWebhookJSONRequestBody defines body for CreateWebhook for application/json ContentType.
type CreateWebhookJSONRequestBody = CreateWebhookRequest

// SearchWebhookRequestsJSONRequestBody defines body for SearchWebhookRequests for application/json ContentType.
type SearchWebhookRequestsJSONRequestBody = WebhookRequestSearchRequest

// Getter for additional properties for CreateFlowRequest_Metadata. Returns the specified
// element and whether it was found
func (a CreateFlowRequest_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for CreateFlowRequest_Metadata
func (a *CreateFlowRequest_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for CreateFlowRequest_Metadata to handle AdditionalProperties
func (a *CreateFlowRequest_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["node_positions"]; found {
		err = json.Unmarshal(raw, &a.NodePositions)
		if err != nil {
			return fmt.Errorf("error reading 'node_positions': %w", err)
		}
		delete(object, "node_positions")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for CreateFlowRequest_Metadata to handle AdditionalProperties
func (a CreateFlowRequest_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.NodePositions != nil {
		object["node_positions"], err = json.Marshal(a.NodePositions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'node_positions': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for DefinitionBase_Metadata. Returns the specified
// element and whether it was found
func (a DefinitionBase_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for DefinitionBase_Metadata
func (a *DefinitionBase_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for DefinitionBase_Metadata to handle AdditionalProperties
func (a *DefinitionBase_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["category"]; found {
		err = json.Unmarshal(raw, &a.Category)
		if err != nil {
			return fmt.Errorf("error reading 'category': %w", err)
		}
		delete(object, "category")
	}

	if raw, found := object["difficulty"]; found {
		err = json.Unmarshal(raw, &a.Difficulty)
		if err != nil {
			return fmt.Errorf("error reading 'difficulty': %w", err)
		}
		delete(object, "difficulty")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for DefinitionBase_Metadata to handle AdditionalProperties
func (a DefinitionBase_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Category != nil {
		object["category"], err = json.Marshal(a.Category)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category': %w", err)
		}
	}

	if a.Difficulty != nil {
		object["difficulty"], err = json.Marshal(a.Difficulty)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'difficulty': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for Flow_Metadata. Returns the specified
// element and whether it was found
func (a Flow_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for Flow_Metadata
func (a *Flow_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for Flow_Metadata to handle AdditionalProperties
func (a *Flow_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["node_positions"]; found {
		err = json.Unmarshal(raw, &a.NodePositions)
		if err != nil {
			return fmt.Errorf("error reading 'node_positions': %w", err)
		}
		delete(object, "node_positions")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for Flow_Metadata to handle AdditionalProperties
func (a Flow_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.NodePositions != nil {
		object["node_positions"], err = json.Marshal(a.NodePositions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'node_positions': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for NodeDefinition_Metadata. Returns the specified
// element and whether it was found
func (a NodeDefinition_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for NodeDefinition_Metadata
func (a *NodeDefinition_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for NodeDefinition_Metadata to handle AdditionalProperties
func (a *NodeDefinition_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["category"]; found {
		err = json.Unmarshal(raw, &a.Category)
		if err != nil {
			return fmt.Errorf("error reading 'category': %w", err)
		}
		delete(object, "category")
	}

	if raw, found := object["difficulty"]; found {
		err = json.Unmarshal(raw, &a.Difficulty)
		if err != nil {
			return fmt.Errorf("error reading 'difficulty': %w", err)
		}
		delete(object, "difficulty")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for NodeDefinition_Metadata to handle AdditionalProperties
func (a NodeDefinition_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Category != nil {
		object["category"], err = json.Marshal(a.Category)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category': %w", err)
		}
	}

	if a.Difficulty != nil {
		object["difficulty"], err = json.Marshal(a.Difficulty)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'difficulty': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for OperationDefinition_Config. Returns the specified
// element and whether it was found
func (a OperationDefinition_Config) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OperationDefinition_Config
func (a *OperationDefinition_Config) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Getter for additional properties for OperationDefinition_Metadata. Returns the specified
// element and whether it was found
func (a OperationDefinition_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for OperationDefinition_Metadata
func (a *OperationDefinition_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for OperationDefinition_Metadata to handle AdditionalProperties
func (a *OperationDefinition_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["category"]; found {
		err = json.Unmarshal(raw, &a.Category)
		if err != nil {
			return fmt.Errorf("error reading 'category': %w", err)
		}
		delete(object, "category")
	}

	if raw, found := object["difficulty"]; found {
		err = json.Unmarshal(raw, &a.Difficulty)
		if err != nil {
			return fmt.Errorf("error reading 'difficulty': %w", err)
		}
		delete(object, "difficulty")
	}

	if raw, found := object["tags"]; found {
		err = json.Unmarshal(raw, &a.Tags)
		if err != nil {
			return fmt.Errorf("error reading 'tags': %w", err)
		}
		delete(object, "tags")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OperationDefinition_Metadata to handle AdditionalProperties
func (a OperationDefinition_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.Category != nil {
		object["category"], err = json.Marshal(a.Category)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'category': %w", err)
		}
	}

	if a.Difficulty != nil {
		object["difficulty"], err = json.Marshal(a.Difficulty)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'difficulty': %w", err)
		}
	}

	if a.Tags != nil {
		object["tags"], err = json.Marshal(a.Tags)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'tags': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for UpdateFlowRequest_Metadata. Returns the specified
// element and whether it was found
func (a UpdateFlowRequest_Metadata) Get(fieldName string) (value interface{}, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for UpdateFlowRequest_Metadata
func (a *UpdateFlowRequest_Metadata) Set(fieldName string, value interface{}) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]interface{})
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for UpdateFlowRequest_Metadata to handle AdditionalProperties
func (a *UpdateFlowRequest_Metadata) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if raw, found := object["node_positions"]; found {
		err = json.Unmarshal(raw, &a.NodePositions)
		if err != nil {
			return fmt.Errorf("error reading 'node_positions': %w", err)
		}
		delete(object, "node_positions")
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for UpdateFlowRequest_Metadata to handle AdditionalProperties
func (a UpdateFlowRequest_Metadata) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	if a.NodePositions != nil {
		object["node_positions"], err = json.Marshal(a.NodePositions)
		if err != nil {
			return nil, fmt.Errorf("error marshaling 'node_positions': %w", err)
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// AsRequestFlowNode returns the union data inside the FlowNode as a RequestFlowNode
func (t FlowNode) AsRequestFlowNode() (RequestFlowNode, error) {
	var body RequestFlowNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromRequestFlowNode overwrites any union data inside the FlowNode as the provided RequestFlowNode
func (t *FlowNode) FromRequestFlowNode(v RequestFlowNode) error {
	v.Type = "request"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeRequestFlowNode performs a merge with any union data inside the FlowNode, using the provided RequestFlowNode
func (t *FlowNode) MergeRequestFlowNode(v RequestFlowNode) error {
	v.Type = "request"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsDelayFlowNode returns the union data inside the FlowNode as a DelayFlowNode
func (t FlowNode) AsDelayFlowNode() (DelayFlowNode, error) {
	var body DelayFlowNode
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromDelayFlowNode overwrites any union data inside the FlowNode as the provided DelayFlowNode
func (t *FlowNode) FromDelayFlowNode(v DelayFlowNode) error {
	v.Type = "delay"
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeDelayFlowNode performs a merge with any union data inside the FlowNode, using the provided DelayFlowNode
func (t *FlowNode) MergeDelayFlowNode(v DelayFlowNode) error {
	v.Type = "delay"
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t FlowNode) Discriminator() (string, error) {
	var discriminator struct {
		Discriminator string `json:"type"`
	}
	err := json.Unmarshal(t.union, &discriminator)
	return discriminator.Discriminator, err
}

func (t FlowNode) ValueByDiscriminator() (interface{}, error) {
	discriminator, err := t.Discriminator()
	if err != nil {
		return nil, err
	}
	switch discriminator {
	case "delay":
		return t.AsDelayFlowNode()
	case "request":
		return t.AsRequestFlowNode()
	default:
		return nil, errors.New("unknown discriminator value: " + discriminator)
	}
}

func (t FlowNode) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *FlowNode) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// AsJSONPathExtractorConfig returns the union data inside the OperationDefinition_Config as a JSONPathExtractorConfig
func (t OperationDefinition_Config) AsJSONPathExtractorConfig() (JSONPathExtractorConfig, error) {
	var body JSONPathExtractorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromJSONPathExtractorConfig overwrites any union data inside the OperationDefinition_Config as the provided JSONPathExtractorConfig
func (t *OperationDefinition_Config) FromJSONPathExtractorConfig(v JSONPathExtractorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeJSONPathExtractorConfig performs a merge with any union data inside the OperationDefinition_Config, using the provided JSONPathExtractorConfig
func (t *OperationDefinition_Config) MergeJSONPathExtractorConfig(v JSONPathExtractorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsXMLPathExtractorConfig returns the union data inside the OperationDefinition_Config as a XMLPathExtractorConfig
func (t OperationDefinition_Config) AsXMLPathExtractorConfig() (XMLPathExtractorConfig, error) {
	var body XMLPathExtractorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromXMLPathExtractorConfig overwrites any union data inside the OperationDefinition_Config as the provided XMLPathExtractorConfig
func (t *OperationDefinition_Config) FromXMLPathExtractorConfig(v XMLPathExtractorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeXMLPathExtractorConfig performs a merge with any union data inside the OperationDefinition_Config, using the provided XMLPathExtractorConfig
func (t *OperationDefinition_Config) MergeXMLPathExtractorConfig(v XMLPathExtractorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsHeaderExtractorConfig returns the union data inside the OperationDefinition_Config as a HeaderExtractorConfig
func (t OperationDefinition_Config) AsHeaderExtractorConfig() (HeaderExtractorConfig, error) {
	var body HeaderExtractorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromHeaderExtractorConfig overwrites any union data inside the OperationDefinition_Config as the provided HeaderExtractorConfig
func (t *OperationDefinition_Config) FromHeaderExtractorConfig(v HeaderExtractorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeHeaderExtractorConfig performs a merge with any union data inside the OperationDefinition_Config, using the provided HeaderExtractorConfig
func (t *OperationDefinition_Config) MergeHeaderExtractorConfig(v HeaderExtractorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsStatusCodeExtractorConfig returns the union data inside the OperationDefinition_Config as a StatusCodeExtractorConfig
func (t OperationDefinition_Config) AsStatusCodeExtractorConfig() (StatusCodeExtractorConfig, error) {
	var body StatusCodeExtractorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromStatusCodeExtractorConfig overwrites any union data inside the OperationDefinition_Config as the provided StatusCodeExtractorConfig
func (t *OperationDefinition_Config) FromStatusCodeExtractorConfig(v StatusCodeExtractorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeStatusCodeExtractorConfig performs a merge with any union data inside the OperationDefinition_Config, using the provided StatusCodeExtractorConfig
func (t *OperationDefinition_Config) MergeStatusCodeExtractorConfig(v StatusCodeExtractorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsBodyExtractorConfig returns the union data inside the OperationDefinition_Config as a BodyExtractorConfig
func (t OperationDefinition_Config) AsBodyExtractorConfig() (BodyExtractorConfig, error) {
	var body BodyExtractorConfig
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromBodyExtractorConfig overwrites any union data inside the OperationDefinition_Config as the provided BodyExtractorConfig
func (t *OperationDefinition_Config) FromBodyExtractorConfig(v BodyExtractorConfig) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeBodyExtractorConfig performs a merge with any union data inside the OperationDefinition_Config, using the provided BodyExtractorConfig
func (t *OperationDefinition_Config) MergeBodyExtractorConfig(v BodyExtractorConfig) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// Override default JSON handling for OperationDefinition_Config to handle AdditionalProperties and union
func (a *OperationDefinition_Config) UnmarshalJSON(b []byte) error {
	err := a.union.UnmarshalJSON(b)
	if err != nil {
		return err
	}
	object := make(map[string]json.RawMessage)
	err = json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]interface{})
		for fieldName, fieldBuf := range object {
			var fieldVal interface{}
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return fmt.Errorf("error unmarshaling field %s: %w", fieldName, err)
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for OperationDefinition_Config to handle AdditionalProperties and union
func (a OperationDefinition_Config) MarshalJSON() ([]byte, error) {
	var err error
	b, err := a.union.MarshalJSON()
	if err != nil {
		return nil, err
	}
	object := make(map[string]json.RawMessage)
	if a.union != nil {
		err = json.Unmarshal(b, &object)
		if err != nil {
			return nil, err
		}
	}

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, fmt.Errorf("error marshaling '%s': %w", fieldName, err)
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// ListCollections request
	ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateCollectionWithBody request with any body
	CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ImportFromOpenAPIWithBody request with any body
	ImportFromOpenAPIWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ImportFromOpenAPI(ctx context.Context, body ImportFromOpenAPIJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFolder request
	DeleteFolder(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFolderWithBody request with any body
	UpdateFolderWithBody(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFolder(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRequest request
	DeleteRequest(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateRequestWithBody request with any body
	UpdateRequestWithBody(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateRequest(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCollection request
	DeleteCollection(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCollection request
	GetCollection(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateCollectionWithBody request with any body
	UpdateCollectionWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateCollection(ctx context.Context, id openapi_types.UUID, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddFolderWithBody request with any body
	AddFolderWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddFolder(ctx context.Context, id openapi_types.UUID, body AddFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddRequestWithBody request with any body
	AddRequestWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddRequest(ctx context.Context, id openapi_types.UUID, body AddRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlows request
	ListFlows(ctx context.Context, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFlowWithBody request with any body
	CreateFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFlow(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExecution request
	GetExecution(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetExecutionNodeResults request
	GetExecutionNodeResults(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNodeExecutionResult request
	GetNodeExecutionResult(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNodeExecutionHistory request
	GetNodeExecutionHistory(ctx context.Context, flowId openapi_types.UUID, nodeId string, params *GetNodeExecutionHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlow request
	DeleteFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlow request
	GetFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlowWithBody request with any body
	UpdateFlowWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlow(ctx context.Context, id openapi_types.UUID, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFlowEnvironment request
	DeleteFlowEnvironment(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFlowEnvironment request
	GetFlowEnvironment(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateOrUpdateFlowEnvironmentWithBody request with any body
	CreateOrUpdateFlowEnvironmentWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateOrUpdateFlowEnvironment(ctx context.Context, id openapi_types.UUID, body CreateOrUpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateFlowEnvironmentWithBody request with any body
	UpdateFlowEnvironmentWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateFlowEnvironment(ctx context.Context, id openapi_types.UUID, body UpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListFlowExecutions request
	ListFlowExecutions(ctx context.Context, id openapi_types.UUID, params *ListFlowExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ExportFlow request
	ExportFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// LaunchFlow request
	LaunchFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// HealthCheck request
	HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListNodes request
	ListNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListOperations request
	ListOperations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveWebhookDeleteWithBody request with any body
	ReceiveWebhookDeleteWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveWebhookGetWithBody request with any body
	ReceiveWebhookGetWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveWebhookPatchWithBody request with any body
	ReceiveWebhookPatchWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveWebhookPostWithBody request with any body
	ReceiveWebhookPostWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReceiveWebhookPutWithBody request with any body
	ReceiveWebhookPutWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateWebhookWithBody request with any body
	CreateWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateWebhook(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteWebhook request
	DeleteWebhook(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhook request
	GetWebhook(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookMethodDistribution request
	GetWebhookMethodDistribution(ctx context.Context, id WebhookIdParameter, params *GetWebhookMethodDistributionParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetWebhookRequestVolumes request
	GetWebhookRequestVolumes(ctx context.Context, id WebhookIdParameter, params *GetWebhookRequestVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SearchWebhookRequestsWithBody request with any body
	SearchWebhookRequestsWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SearchWebhookRequests(ctx context.Context, id WebhookIdParameter, body SearchWebhookRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// StreamWebhookRequests request
	StreamWebhookRequests(ctx context.Context, id WebhookIdParameter, params *StreamWebhookRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) ListCollections(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListCollectionsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollectionWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateCollection(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateCollectionRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportFromOpenAPIWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportFromOpenAPIRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ImportFromOpenAPI(ctx context.Context, body ImportFromOpenAPIJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewImportFromOpenAPIRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFolder(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFolderRequest(c.Server, collectionId, folderId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolderWithBody(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequestWithBody(c.Server, collectionId, folderId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFolder(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFolderRequest(c.Server, collectionId, folderId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRequest(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequestRequest(c.Server, collectionId, requestId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequestWithBody(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestRequestWithBody(c.Server, collectionId, requestId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateRequest(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateRequestRequest(c.Server, collectionId, requestId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCollection(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCollectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCollection(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCollectionRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollectionWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateCollection(ctx context.Context, id openapi_types.UUID, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateCollectionRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFolderWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFolderRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddFolder(ctx context.Context, id openapi_types.UUID, body AddFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddFolderRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRequestWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRequestRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddRequest(ctx context.Context, id openapi_types.UUID, body AddRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddRequestRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlows(ctx context.Context, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlowWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFlow(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFlowRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExecution(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExecutionRequest(c.Server, flowId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetExecutionNodeResults(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetExecutionNodeResultsRequest(c.Server, flowId, executionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodeExecutionResult(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, nodeId string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodeExecutionResultRequest(c.Server, flowId, executionId, nodeId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNodeExecutionHistory(ctx context.Context, flowId openapi_types.UUID, nodeId string, params *GetNodeExecutionHistoryParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNodeExecutionHistoryRequest(c.Server, flowId, nodeId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlow(ctx context.Context, id openapi_types.UUID, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFlowEnvironment(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFlowEnvironmentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFlowEnvironment(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFlowEnvironmentRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateFlowEnvironmentWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateFlowEnvironmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateOrUpdateFlowEnvironment(ctx context.Context, id openapi_types.UUID, body CreateOrUpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateOrUpdateFlowEnvironmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowEnvironmentWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowEnvironmentRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateFlowEnvironment(ctx context.Context, id openapi_types.UUID, body UpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateFlowEnvironmentRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListFlowExecutions(ctx context.Context, id openapi_types.UUID, params *ListFlowExecutionsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListFlowExecutionsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ExportFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExportFlowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) LaunchFlow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewLaunchFlowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) HealthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewHealthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListNodes(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListNodesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListOperations(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListOperationsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveWebhookDeleteWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveWebhookDeleteRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveWebhookGetWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveWebhookGetRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveWebhookPatchWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveWebhookPatchRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveWebhookPostWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveWebhookPostRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReceiveWebhookPutWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReceiveWebhookPutRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhookWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateWebhook(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateWebhookRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteWebhook(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteWebhookRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhook(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookMethodDistribution(ctx context.Context, id WebhookIdParameter, params *GetWebhookMethodDistributionParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookMethodDistributionRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetWebhookRequestVolumes(ctx context.Context, id WebhookIdParameter, params *GetWebhookRequestVolumesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetWebhookRequestVolumesRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWebhookRequestsWithBody(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWebhookRequestsRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SearchWebhookRequests(ctx context.Context, id WebhookIdParameter, body SearchWebhookRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchWebhookRequestsRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) StreamWebhookRequests(ctx context.Context, id WebhookIdParameter, params *StreamWebhookRequestsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewStreamWebhookRequestsRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewListCollectionsRequest generates requests for ListCollections
func NewListCollectionsRequest(server string, params *ListCollectionsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateCollectionRequest calls the generic CreateCollection builder with application/json body
func NewCreateCollectionRequest(server string, body CreateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateCollectionRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateCollectionRequestWithBody generates requests for CreateCollection with any type of body
func NewCreateCollectionRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewImportFromOpenAPIRequest calls the generic ImportFromOpenAPI builder with application/json body
func NewImportFromOpenAPIRequest(server string, body ImportFromOpenAPIJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewImportFromOpenAPIRequestWithBody(server, "application/json", bodyReader)
}

// NewImportFromOpenAPIRequestWithBody generates requests for ImportFromOpenAPI with any type of body
func NewImportFromOpenAPIRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/import/openapi")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFolderRequest generates requests for DeleteFolder
func NewDeleteFolderRequest(server string, collectionId openapi_types.UUID, folderId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "folderId", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/folders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFolderRequest calls the generic UpdateFolder builder with application/json body
func NewUpdateFolderRequest(server string, collectionId openapi_types.UUID, folderId openapi_types.UUID, body UpdateFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFolderRequestWithBody(server, collectionId, folderId, "application/json", bodyReader)
}

// NewUpdateFolderRequestWithBody generates requests for UpdateFolder with any type of body
func NewUpdateFolderRequestWithBody(server string, collectionId openapi_types.UUID, folderId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "folderId", runtime.ParamLocationPath, folderId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/folders/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteRequestRequest generates requests for DeleteRequest
func NewDeleteRequestRequest(server string, collectionId openapi_types.UUID, requestId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "requestId", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/requests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateRequestRequest calls the generic UpdateRequest builder with application/json body
func NewUpdateRequestRequest(server string, collectionId openapi_types.UUID, requestId openapi_types.UUID, body UpdateRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateRequestRequestWithBody(server, collectionId, requestId, "application/json", bodyReader)
}

// NewUpdateRequestRequestWithBody generates requests for UpdateRequest with any type of body
func NewUpdateRequestRequestWithBody(server string, collectionId openapi_types.UUID, requestId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "collectionId", runtime.ParamLocationPath, collectionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "requestId", runtime.ParamLocationPath, requestId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/requests/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteCollectionRequest generates requests for DeleteCollection
func NewDeleteCollectionRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCollectionRequest generates requests for GetCollection
func NewGetCollectionRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateCollectionRequest calls the generic UpdateCollection builder with application/json body
func NewUpdateCollectionRequest(server string, id openapi_types.UUID, body UpdateCollectionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateCollectionRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateCollectionRequestWithBody generates requests for UpdateCollection with any type of body
func NewUpdateCollectionRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddFolderRequest calls the generic AddFolder builder with application/json body
func NewAddFolderRequest(server string, id openapi_types.UUID, body AddFolderJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddFolderRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddFolderRequestWithBody generates requests for AddFolder with any type of body
func NewAddFolderRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/folders", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddRequestRequest calls the generic AddRequest builder with application/json body
func NewAddRequestRequest(server string, id openapi_types.UUID, body AddRequestJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddRequestRequestWithBody(server, id, "application/json", bodyReader)
}

// NewAddRequestRequestWithBody generates requests for AddRequest with any type of body
func NewAddRequestRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/collections/%s/requests", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFlowsRequest generates requests for ListFlows
func NewListFlowsRequest(server string, params *ListFlowsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFlowRequest calls the generic CreateFlow builder with application/json body
func NewCreateFlowRequest(server string, body CreateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFlowRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateFlowRequestWithBody generates requests for CreateFlow with any type of body
func NewCreateFlowRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetExecutionRequest generates requests for GetExecution
func NewGetExecutionRequest(server string, flowId openapi_types.UUID, executionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "flowId", runtime.ParamLocationPath, flowId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/executions/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetExecutionNodeResultsRequest generates requests for GetExecutionNodeResults
func NewGetExecutionNodeResultsRequest(server string, flowId openapi_types.UUID, executionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "flowId", runtime.ParamLocationPath, flowId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/executions/%s/nodes", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodeExecutionResultRequest generates requests for GetNodeExecutionResult
func NewGetNodeExecutionResultRequest(server string, flowId openapi_types.UUID, executionId openapi_types.UUID, nodeId string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "flowId", runtime.ParamLocationPath, flowId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "executionId", runtime.ParamLocationPath, executionId)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "nodeId", runtime.ParamLocationPath, nodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/executions/%s/nodes/%s", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNodeExecutionHistoryRequest generates requests for GetNodeExecutionHistory
func NewGetNodeExecutionHistoryRequest(server string, flowId openapi_types.UUID, nodeId string, params *GetNodeExecutionHistoryParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "flowId", runtime.ParamLocationPath, flowId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "nodeId", runtime.ParamLocationPath, nodeId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/nodes/%s/executions", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFlowRequest generates requests for DeleteFlow
func NewDeleteFlowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowRequest generates requests for GetFlow
func NewGetFlowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateFlowRequest calls the generic UpdateFlow builder with application/json body
func NewUpdateFlowRequest(server string, id openapi_types.UUID, body UpdateFlowJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlowRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateFlowRequestWithBody generates requests for UpdateFlow with any type of body
func NewUpdateFlowRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteFlowEnvironmentRequest generates requests for DeleteFlowEnvironment
func NewDeleteFlowEnvironmentRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/environments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetFlowEnvironmentRequest generates requests for GetFlowEnvironment
func NewGetFlowEnvironmentRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/environments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateOrUpdateFlowEnvironmentRequest calls the generic CreateOrUpdateFlowEnvironment builder with application/json body
func NewCreateOrUpdateFlowEnvironmentRequest(server string, id openapi_types.UUID, body CreateOrUpdateFlowEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateOrUpdateFlowEnvironmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCreateOrUpdateFlowEnvironmentRequestWithBody generates requests for CreateOrUpdateFlowEnvironment with any type of body
func NewCreateOrUpdateFlowEnvironmentRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/environments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateFlowEnvironmentRequest calls the generic UpdateFlowEnvironment builder with application/json body
func NewUpdateFlowEnvironmentRequest(server string, id openapi_types.UUID, body UpdateFlowEnvironmentJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateFlowEnvironmentRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUpdateFlowEnvironmentRequestWithBody generates requests for UpdateFlowEnvironment with any type of body
func NewUpdateFlowEnvironmentRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/environments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewListFlowExecutionsRequest generates requests for ListFlowExecutions
func NewListFlowExecutionsRequest(server string, id openapi_types.UUID, params *ListFlowExecutionsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/executions", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, params.Offset); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExportFlowRequest generates requests for ExportFlow
func NewExportFlowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/export", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewLaunchFlowRequest generates requests for LaunchFlow
func NewLaunchFlowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/flows/%s/launch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewHealthCheckRequest generates requests for HealthCheck
func NewHealthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/health")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListNodesRequest generates requests for ListNodes
func NewListNodesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/nodes")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListOperationsRequest generates requests for ListOperations
func NewListOperationsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/operations")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReceiveWebhookDeleteRequestWithBody generates requests for ReceiveWebhookDelete with any type of body
func NewReceiveWebhookDeleteRequestWithBody(server string, id WebhookIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhook/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReceiveWebhookGetRequestWithBody generates requests for ReceiveWebhookGet with any type of body
func NewReceiveWebhookGetRequestWithBody(server string, id WebhookIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhook/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReceiveWebhookPatchRequestWithBody generates requests for ReceiveWebhookPatch with any type of body
func NewReceiveWebhookPatchRequestWithBody(server string, id WebhookIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhook/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReceiveWebhookPostRequestWithBody generates requests for ReceiveWebhookPost with any type of body
func NewReceiveWebhookPostRequestWithBody(server string, id WebhookIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhook/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReceiveWebhookPutRequestWithBody generates requests for ReceiveWebhookPut with any type of body
func NewReceiveWebhookPutRequestWithBody(server string, id WebhookIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhook/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewCreateWebhookRequest calls the generic CreateWebhook builder with application/json body
func NewCreateWebhookRequest(server string, body CreateWebhookJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateWebhookRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateWebhookRequestWithBody generates requests for CreateWebhook with any type of body
func NewCreateWebhookRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteWebhookRequest generates requests for DeleteWebhook
func NewDeleteWebhookRequest(server string, id WebhookIdParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookRequest generates requests for GetWebhook
func NewGetWebhookRequest(server string, id WebhookIdParameter) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookMethodDistributionRequest generates requests for GetWebhookMethodDistribution
func NewGetWebhookMethodDistributionRequest(server string, id WebhookIdParameter, params *GetWebhookMethodDistributionParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/analytics/requests/methods", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetWebhookRequestVolumesRequest generates requests for GetWebhookRequestVolumes
func NewGetWebhookRequestVolumesRequest(server string, id WebhookIdParameter, params *GetWebhookRequestVolumesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/analytics/requests/volumes", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, params.From); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, params.To); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchWebhookRequestsRequest calls the generic SearchWebhookRequests builder with application/json body
func NewSearchWebhookRequestsRequest(server string, id WebhookIdParameter, body SearchWebhookRequestsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSearchWebhookRequestsRequestWithBody(server, id, "application/json", bodyReader)
}

// NewSearchWebhookRequestsRequestWithBody generates requests for SearchWebhookRequests with any type of body
func NewSearchWebhookRequestsRequestWithBody(server string, id WebhookIdParameter, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/requests/search", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewStreamWebhookRequestsRequest generates requests for StreamWebhookRequests
func NewStreamWebhookRequestsRequest(server string, id WebhookIdParameter, params *StreamWebhookRequestsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/webhooks/%s/stream", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// ListCollectionsWithResponse request
	ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error)

	// CreateCollectionWithBodyWithResponse request with any body
	CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error)

	// ImportFromOpenAPIWithBodyWithResponse request with any body
	ImportFromOpenAPIWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportFromOpenAPIResponse, error)

	ImportFromOpenAPIWithResponse(ctx context.Context, body ImportFromOpenAPIJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportFromOpenAPIResponse, error)

	// DeleteFolderWithResponse request
	DeleteFolderWithResponse(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error)

	// UpdateFolderWithBodyWithResponse request with any body
	UpdateFolderWithBodyWithResponse(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	UpdateFolderWithResponse(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error)

	// DeleteRequestWithResponse request
	DeleteRequestWithResponse(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRequestResponse, error)

	// UpdateRequestWithBodyWithResponse request with any body
	UpdateRequestWithBodyWithResponse(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestResponse, error)

	UpdateRequestWithResponse(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestResponse, error)

	// DeleteCollectionWithResponse request
	DeleteCollectionWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error)

	// GetCollectionWithResponse request
	GetCollectionWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error)

	// UpdateCollectionWithBodyWithResponse request with any body
	UpdateCollectionWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	UpdateCollectionWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error)

	// AddFolderWithBodyWithResponse request with any body
	AddFolderWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFolderResponse, error)

	AddFolderWithResponse(ctx context.Context, id openapi_types.UUID, body AddFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFolderResponse, error)

	// AddRequestWithBodyWithResponse request with any body
	AddRequestWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRequestResponse, error)

	AddRequestWithResponse(ctx context.Context, id openapi_types.UUID, body AddRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRequestResponse, error)

	// ListFlowsWithResponse request
	ListFlowsWithResponse(ctx context.Context, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error)

	// CreateFlowWithBodyWithResponse request with any body
	CreateFlowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	CreateFlowWithResponse(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error)

	// GetExecutionWithResponse request
	GetExecutionWithResponse(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetExecutionResponse, error)

	// GetExecutionNodeResultsWithResponse request
	GetExecutionNodeResultsWithResponse(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetExecutionNodeResultsResponse, error)

	// GetNodeExecutionResultWithResponse request
	GetNodeExecutionResultWithResponse(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, nodeId string, reqEditors ...RequestEditorFn) (*GetNodeExecutionResultResponse, error)

	// GetNodeExecutionHistoryWithResponse request
	GetNodeExecutionHistoryWithResponse(ctx context.Context, flowId openapi_types.UUID, nodeId string, params *GetNodeExecutionHistoryParams, reqEditors ...RequestEditorFn) (*GetNodeExecutionHistoryResponse, error)

	// DeleteFlowWithResponse request
	DeleteFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFlowResponse, error)

	// GetFlowWithResponse request
	GetFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFlowResponse, error)

	// UpdateFlowWithBodyWithResponse request with any body
	UpdateFlowWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	UpdateFlowWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error)

	// DeleteFlowEnvironmentWithResponse request
	DeleteFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFlowEnvironmentResponse, error)

	// GetFlowEnvironmentWithResponse request
	GetFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFlowEnvironmentResponse, error)

	// CreateOrUpdateFlowEnvironmentWithBodyWithResponse request with any body
	CreateOrUpdateFlowEnvironmentWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateFlowEnvironmentResponse, error)

	CreateOrUpdateFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, body CreateOrUpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateFlowEnvironmentResponse, error)

	// UpdateFlowEnvironmentWithBodyWithResponse request with any body
	UpdateFlowEnvironmentWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowEnvironmentResponse, error)

	UpdateFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowEnvironmentResponse, error)

	// ListFlowExecutionsWithResponse request
	ListFlowExecutionsWithResponse(ctx context.Context, id openapi_types.UUID, params *ListFlowExecutionsParams, reqEditors ...RequestEditorFn) (*ListFlowExecutionsResponse, error)

	// ExportFlowWithResponse request
	ExportFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ExportFlowResponse, error)

	// LaunchFlowWithResponse request
	LaunchFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*LaunchFlowResponse, error)

	// HealthCheckWithResponse request
	HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error)

	// ListNodesWithResponse request
	ListNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNodesResponse, error)

	// ListOperationsWithResponse request
	ListOperationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error)

	// ReceiveWebhookDeleteWithBodyWithResponse request with any body
	ReceiveWebhookDeleteWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookDeleteResponse, error)

	// ReceiveWebhookGetWithBodyWithResponse request with any body
	ReceiveWebhookGetWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookGetResponse, error)

	// ReceiveWebhookPatchWithBodyWithResponse request with any body
	ReceiveWebhookPatchWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookPatchResponse, error)

	// ReceiveWebhookPostWithBodyWithResponse request with any body
	ReceiveWebhookPostWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookPostResponse, error)

	// ReceiveWebhookPutWithBodyWithResponse request with any body
	ReceiveWebhookPutWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookPutResponse, error)

	// CreateWebhookWithBodyWithResponse request with any body
	CreateWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	CreateWebhookWithResponse(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error)

	// DeleteWebhookWithResponse request
	DeleteWebhookWithResponse(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error)

	// GetWebhookWithResponse request
	GetWebhookWithResponse(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error)

	// GetWebhookMethodDistributionWithResponse request
	GetWebhookMethodDistributionWithResponse(ctx context.Context, id WebhookIdParameter, params *GetWebhookMethodDistributionParams, reqEditors ...RequestEditorFn) (*GetWebhookMethodDistributionResponse, error)

	// GetWebhookRequestVolumesWithResponse request
	GetWebhookRequestVolumesWithResponse(ctx context.Context, id WebhookIdParameter, params *GetWebhookRequestVolumesParams, reqEditors ...RequestEditorFn) (*GetWebhookRequestVolumesResponse, error)

	// SearchWebhookRequestsWithBodyWithResponse request with any body
	SearchWebhookRequestsWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchWebhookRequestsResponse, error)

	SearchWebhookRequestsWithResponse(ctx context.Context, id WebhookIdParameter, body SearchWebhookRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchWebhookRequestsResponse, error)

	// StreamWebhookRequestsWithResponse request
	StreamWebhookRequestsWithResponse(ctx context.Context, id WebhookIdParameter, params *StreamWebhookRequestsParams, reqEditors ...RequestEditorFn) (*StreamWebhookRequestsResponse, error)
}

type ListCollectionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionListResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListCollectionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListCollectionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Collection
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ImportFromOpenAPIResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *OpenAPIImportResult
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ImportFromOpenAPIResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ImportFromOpenAPIResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionFolder
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CollectionRequest
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateCollectionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Collection
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateCollectionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateCollectionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddFolderResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CollectionFolder
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddFolderResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddFolderResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddRequestResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *CollectionRequest
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r AddRequestResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddRequestResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlowListResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListFlowsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Flow
	JSON400      *BadRequest
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r CreateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExecutionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlowExecution
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetExecutionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExecutionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetExecutionNodeResultsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NodeExecutionResult
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetExecutionNodeResultsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetExecutionNodeResultsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodeExecutionResultResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NodeExecutionResult
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetNodeExecutionResultResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodeExecutionResultResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNodeExecutionHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *NodeExecutionHistoryResponse
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetNodeExecutionHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNodeExecutionHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r DeleteFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flow
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Flow
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFlowEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteFlowEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFlowEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFlowEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetFlowEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFlowEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateOrUpdateFlowEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON201      *Environment
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r CreateOrUpdateFlowEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateOrUpdateFlowEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateFlowEnvironmentResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Environment
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r UpdateFlowEnvironmentResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateFlowEnvironmentResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListFlowExecutionsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *FlowExecutionListResponse
	JSON400      *BadRequest
	JSON401      *Unauthorized
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ListFlowExecutionsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListFlowExecutionsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExportFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ExportedFlow
	JSON401      *Unauthorized
	JSON404      *NotFound
	JSON500      *InternalServerError
}

// Status returns HTTPResponse.Status
func (r ExportFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExportFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type LaunchFlowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *BadRequest
	JSON500      *ApiErrorResponse
}

// Status returns HTTPResponse.Status
func (r LaunchFlowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r LaunchFlowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type HealthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Status string `json:"status"`
	}
}

// Status returns HTTPResponse.Status
func (r HealthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r HealthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListNodesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]NodeDefinition
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListNodesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListNodesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListOperationsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]OperationDefinition
	JSON401      *Unauthorized
}

// Status returns HTTPResponse.Status
func (r ListOperationsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListOperationsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveWebhookDeleteResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ReceiveWebhookDeleteResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveWebhookDeleteResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveWebhookGetResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ReceiveWebhookGetResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveWebhookGetResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveWebhookPatchResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ReceiveWebhookPatchResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveWebhookPatchResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveWebhookPostResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ReceiveWebhookPostResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveWebhookPostResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReceiveWebhookPutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookResponse
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r ReceiveWebhookPutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReceiveWebhookPutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Webhook
	JSON400      *BadRequest
	JSON409      *Conflict
}

// Status returns HTTPResponse.Status
func (r CreateWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Webhook
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetWebhookResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookMethodDistributionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MethodDistributionResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetWebhookMethodDistributionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookMethodDistributionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetWebhookRequestVolumesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RequestVolumesResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r GetWebhookRequestVolumesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWebhookRequestVolumesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchWebhookRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *WebhookRequestListResponse
	JSON400      *BadRequest
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r SearchWebhookRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchWebhookRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type StreamWebhookRequestsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r StreamWebhookRequestsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r StreamWebhookRequestsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// ListCollectionsWithResponse request returning *ListCollectionsResponse
func (c *ClientWithResponses) ListCollectionsWithResponse(ctx context.Context, params *ListCollectionsParams, reqEditors ...RequestEditorFn) (*ListCollectionsResponse, error) {
	rsp, err := c.ListCollections(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListCollectionsResponse(rsp)
}

// CreateCollectionWithBodyWithResponse request with arbitrary body returning *CreateCollectionResponse
func (c *ClientWithResponses) CreateCollectionWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollectionWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

func (c *ClientWithResponses) CreateCollectionWithResponse(ctx context.Context, body CreateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateCollectionResponse, error) {
	rsp, err := c.CreateCollection(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateCollectionResponse(rsp)
}

// ImportFromOpenAPIWithBodyWithResponse request with arbitrary body returning *ImportFromOpenAPIResponse
func (c *ClientWithResponses) ImportFromOpenAPIWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ImportFromOpenAPIResponse, error) {
	rsp, err := c.ImportFromOpenAPIWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportFromOpenAPIResponse(rsp)
}

func (c *ClientWithResponses) ImportFromOpenAPIWithResponse(ctx context.Context, body ImportFromOpenAPIJSONRequestBody, reqEditors ...RequestEditorFn) (*ImportFromOpenAPIResponse, error) {
	rsp, err := c.ImportFromOpenAPI(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseImportFromOpenAPIResponse(rsp)
}

// DeleteFolderWithResponse request returning *DeleteFolderResponse
func (c *ClientWithResponses) DeleteFolderWithResponse(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFolderResponse, error) {
	rsp, err := c.DeleteFolder(ctx, collectionId, folderId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFolderResponse(rsp)
}

// UpdateFolderWithBodyWithResponse request with arbitrary body returning *UpdateFolderResponse
func (c *ClientWithResponses) UpdateFolderWithBodyWithResponse(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolderWithBody(ctx, collectionId, folderId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

func (c *ClientWithResponses) UpdateFolderWithResponse(ctx context.Context, collectionId openapi_types.UUID, folderId openapi_types.UUID, body UpdateFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFolderResponse, error) {
	rsp, err := c.UpdateFolder(ctx, collectionId, folderId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFolderResponse(rsp)
}

// DeleteRequestWithResponse request returning *DeleteRequestResponse
func (c *ClientWithResponses) DeleteRequestWithResponse(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRequestResponse, error) {
	rsp, err := c.DeleteRequest(ctx, collectionId, requestId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRequestResponse(rsp)
}

// UpdateRequestWithBodyWithResponse request with arbitrary body returning *UpdateRequestResponse
func (c *ClientWithResponses) UpdateRequestWithBodyWithResponse(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateRequestResponse, error) {
	rsp, err := c.UpdateRequestWithBody(ctx, collectionId, requestId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestResponse(rsp)
}

func (c *ClientWithResponses) UpdateRequestWithResponse(ctx context.Context, collectionId openapi_types.UUID, requestId openapi_types.UUID, body UpdateRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateRequestResponse, error) {
	rsp, err := c.UpdateRequest(ctx, collectionId, requestId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateRequestResponse(rsp)
}

// DeleteCollectionWithResponse request returning *DeleteCollectionResponse
func (c *ClientWithResponses) DeleteCollectionWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCollectionResponse, error) {
	rsp, err := c.DeleteCollection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCollectionResponse(rsp)
}

// GetCollectionWithResponse request returning *GetCollectionResponse
func (c *ClientWithResponses) GetCollectionWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetCollectionResponse, error) {
	rsp, err := c.GetCollection(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCollectionResponse(rsp)
}

// UpdateCollectionWithBodyWithResponse request with arbitrary body returning *UpdateCollectionResponse
func (c *ClientWithResponses) UpdateCollectionWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollectionWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

func (c *ClientWithResponses) UpdateCollectionWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateCollectionJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateCollectionResponse, error) {
	rsp, err := c.UpdateCollection(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateCollectionResponse(rsp)
}

// AddFolderWithBodyWithResponse request with arbitrary body returning *AddFolderResponse
func (c *ClientWithResponses) AddFolderWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddFolderResponse, error) {
	rsp, err := c.AddFolderWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFolderResponse(rsp)
}

func (c *ClientWithResponses) AddFolderWithResponse(ctx context.Context, id openapi_types.UUID, body AddFolderJSONRequestBody, reqEditors ...RequestEditorFn) (*AddFolderResponse, error) {
	rsp, err := c.AddFolder(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddFolderResponse(rsp)
}

// AddRequestWithBodyWithResponse request with arbitrary body returning *AddRequestResponse
func (c *ClientWithResponses) AddRequestWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddRequestResponse, error) {
	rsp, err := c.AddRequestWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRequestResponse(rsp)
}

func (c *ClientWithResponses) AddRequestWithResponse(ctx context.Context, id openapi_types.UUID, body AddRequestJSONRequestBody, reqEditors ...RequestEditorFn) (*AddRequestResponse, error) {
	rsp, err := c.AddRequest(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddRequestResponse(rsp)
}

// ListFlowsWithResponse request returning *ListFlowsResponse
func (c *ClientWithResponses) ListFlowsWithResponse(ctx context.Context, params *ListFlowsParams, reqEditors ...RequestEditorFn) (*ListFlowsResponse, error) {
	rsp, err := c.ListFlows(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowsResponse(rsp)
}

// CreateFlowWithBodyWithResponse request with arbitrary body returning *CreateFlowResponse
func (c *ClientWithResponses) CreateFlowWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlowWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

func (c *ClientWithResponses) CreateFlowWithResponse(ctx context.Context, body CreateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFlowResponse, error) {
	rsp, err := c.CreateFlow(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFlowResponse(rsp)
}

// GetExecutionWithResponse request returning *GetExecutionResponse
func (c *ClientWithResponses) GetExecutionWithResponse(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetExecutionResponse, error) {
	rsp, err := c.GetExecution(ctx, flowId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExecutionResponse(rsp)
}

// GetExecutionNodeResultsWithResponse request returning *GetExecutionNodeResultsResponse
func (c *ClientWithResponses) GetExecutionNodeResultsWithResponse(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetExecutionNodeResultsResponse, error) {
	rsp, err := c.GetExecutionNodeResults(ctx, flowId, executionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetExecutionNodeResultsResponse(rsp)
}

// GetNodeExecutionResultWithResponse request returning *GetNodeExecutionResultResponse
func (c *ClientWithResponses) GetNodeExecutionResultWithResponse(ctx context.Context, flowId openapi_types.UUID, executionId openapi_types.UUID, nodeId string, reqEditors ...RequestEditorFn) (*GetNodeExecutionResultResponse, error) {
	rsp, err := c.GetNodeExecutionResult(ctx, flowId, executionId, nodeId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodeExecutionResultResponse(rsp)
}

// GetNodeExecutionHistoryWithResponse request returning *GetNodeExecutionHistoryResponse
func (c *ClientWithResponses) GetNodeExecutionHistoryWithResponse(ctx context.Context, flowId openapi_types.UUID, nodeId string, params *GetNodeExecutionHistoryParams, reqEditors ...RequestEditorFn) (*GetNodeExecutionHistoryResponse, error) {
	rsp, err := c.GetNodeExecutionHistory(ctx, flowId, nodeId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNodeExecutionHistoryResponse(rsp)
}

// DeleteFlowWithResponse request returning *DeleteFlowResponse
func (c *ClientWithResponses) DeleteFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFlowResponse, error) {
	rsp, err := c.DeleteFlow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlowResponse(rsp)
}

// GetFlowWithResponse request returning *GetFlowResponse
func (c *ClientWithResponses) GetFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFlowResponse, error) {
	rsp, err := c.GetFlow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowResponse(rsp)
}

// UpdateFlowWithBodyWithResponse request with arbitrary body returning *UpdateFlowResponse
func (c *ClientWithResponses) UpdateFlowWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlowWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlowWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateFlowJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowResponse, error) {
	rsp, err := c.UpdateFlow(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowResponse(rsp)
}

// DeleteFlowEnvironmentWithResponse request returning *DeleteFlowEnvironmentResponse
func (c *ClientWithResponses) DeleteFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteFlowEnvironmentResponse, error) {
	rsp, err := c.DeleteFlowEnvironment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFlowEnvironmentResponse(rsp)
}

// GetFlowEnvironmentWithResponse request returning *GetFlowEnvironmentResponse
func (c *ClientWithResponses) GetFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetFlowEnvironmentResponse, error) {
	rsp, err := c.GetFlowEnvironment(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFlowEnvironmentResponse(rsp)
}

// CreateOrUpdateFlowEnvironmentWithBodyWithResponse request with arbitrary body returning *CreateOrUpdateFlowEnvironmentResponse
func (c *ClientWithResponses) CreateOrUpdateFlowEnvironmentWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateOrUpdateFlowEnvironmentResponse, error) {
	rsp, err := c.CreateOrUpdateFlowEnvironmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateFlowEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) CreateOrUpdateFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, body CreateOrUpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateOrUpdateFlowEnvironmentResponse, error) {
	rsp, err := c.CreateOrUpdateFlowEnvironment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateOrUpdateFlowEnvironmentResponse(rsp)
}

// UpdateFlowEnvironmentWithBodyWithResponse request with arbitrary body returning *UpdateFlowEnvironmentResponse
func (c *ClientWithResponses) UpdateFlowEnvironmentWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateFlowEnvironmentResponse, error) {
	rsp, err := c.UpdateFlowEnvironmentWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowEnvironmentResponse(rsp)
}

func (c *ClientWithResponses) UpdateFlowEnvironmentWithResponse(ctx context.Context, id openapi_types.UUID, body UpdateFlowEnvironmentJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateFlowEnvironmentResponse, error) {
	rsp, err := c.UpdateFlowEnvironment(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateFlowEnvironmentResponse(rsp)
}

// ListFlowExecutionsWithResponse request returning *ListFlowExecutionsResponse
func (c *ClientWithResponses) ListFlowExecutionsWithResponse(ctx context.Context, id openapi_types.UUID, params *ListFlowExecutionsParams, reqEditors ...RequestEditorFn) (*ListFlowExecutionsResponse, error) {
	rsp, err := c.ListFlowExecutions(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListFlowExecutionsResponse(rsp)
}

// ExportFlowWithResponse request returning *ExportFlowResponse
func (c *ClientWithResponses) ExportFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*ExportFlowResponse, error) {
	rsp, err := c.ExportFlow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExportFlowResponse(rsp)
}

// LaunchFlowWithResponse request returning *LaunchFlowResponse
func (c *ClientWithResponses) LaunchFlowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*LaunchFlowResponse, error) {
	rsp, err := c.LaunchFlow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseLaunchFlowResponse(rsp)
}

// HealthCheckWithResponse request returning *HealthCheckResponse
func (c *ClientWithResponses) HealthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*HealthCheckResponse, error) {
	rsp, err := c.HealthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseHealthCheckResponse(rsp)
}

// ListNodesWithResponse request returning *ListNodesResponse
func (c *ClientWithResponses) ListNodesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListNodesResponse, error) {
	rsp, err := c.ListNodes(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListNodesResponse(rsp)
}

// ListOperationsWithResponse request returning *ListOperationsResponse
func (c *ClientWithResponses) ListOperationsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListOperationsResponse, error) {
	rsp, err := c.ListOperations(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListOperationsResponse(rsp)
}

// ReceiveWebhookDeleteWithBodyWithResponse request with arbitrary body returning *ReceiveWebhookDeleteResponse
func (c *ClientWithResponses) ReceiveWebhookDeleteWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookDeleteResponse, error) {
	rsp, err := c.ReceiveWebhookDeleteWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveWebhookDeleteResponse(rsp)
}

// ReceiveWebhookGetWithBodyWithResponse request with arbitrary body returning *ReceiveWebhookGetResponse
func (c *ClientWithResponses) ReceiveWebhookGetWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookGetResponse, error) {
	rsp, err := c.ReceiveWebhookGetWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveWebhookGetResponse(rsp)
}

// ReceiveWebhookPatchWithBodyWithResponse request with arbitrary body returning *ReceiveWebhookPatchResponse
func (c *ClientWithResponses) ReceiveWebhookPatchWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookPatchResponse, error) {
	rsp, err := c.ReceiveWebhookPatchWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveWebhookPatchResponse(rsp)
}

// ReceiveWebhookPostWithBodyWithResponse request with arbitrary body returning *ReceiveWebhookPostResponse
func (c *ClientWithResponses) ReceiveWebhookPostWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookPostResponse, error) {
	rsp, err := c.ReceiveWebhookPostWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveWebhookPostResponse(rsp)
}

// ReceiveWebhookPutWithBodyWithResponse request with arbitrary body returning *ReceiveWebhookPutResponse
func (c *ClientWithResponses) ReceiveWebhookPutWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReceiveWebhookPutResponse, error) {
	rsp, err := c.ReceiveWebhookPutWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReceiveWebhookPutResponse(rsp)
}

// CreateWebhookWithBodyWithResponse request with arbitrary body returning *CreateWebhookResponse
func (c *ClientWithResponses) CreateWebhookWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhookWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

func (c *ClientWithResponses) CreateWebhookWithResponse(ctx context.Context, body CreateWebhookJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateWebhookResponse, error) {
	rsp, err := c.CreateWebhook(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateWebhookResponse(rsp)
}

// DeleteWebhookWithResponse request returning *DeleteWebhookResponse
func (c *ClientWithResponses) DeleteWebhookWithResponse(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*DeleteWebhookResponse, error) {
	rsp, err := c.DeleteWebhook(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteWebhookResponse(rsp)
}

// GetWebhookWithResponse request returning *GetWebhookResponse
func (c *ClientWithResponses) GetWebhookWithResponse(ctx context.Context, id WebhookIdParameter, reqEditors ...RequestEditorFn) (*GetWebhookResponse, error) {
	rsp, err := c.GetWebhook(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookResponse(rsp)
}

// GetWebhookMethodDistributionWithResponse request returning *GetWebhookMethodDistributionResponse
func (c *ClientWithResponses) GetWebhookMethodDistributionWithResponse(ctx context.Context, id WebhookIdParameter, params *GetWebhookMethodDistributionParams, reqEditors ...RequestEditorFn) (*GetWebhookMethodDistributionResponse, error) {
	rsp, err := c.GetWebhookMethodDistribution(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookMethodDistributionResponse(rsp)
}

// GetWebhookRequestVolumesWithResponse request returning *GetWebhookRequestVolumesResponse
func (c *ClientWithResponses) GetWebhookRequestVolumesWithResponse(ctx context.Context, id WebhookIdParameter, params *GetWebhookRequestVolumesParams, reqEditors ...RequestEditorFn) (*GetWebhookRequestVolumesResponse, error) {
	rsp, err := c.GetWebhookRequestVolumes(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetWebhookRequestVolumesResponse(rsp)
}

// SearchWebhookRequestsWithBodyWithResponse request with arbitrary body returning *SearchWebhookRequestsResponse
func (c *ClientWithResponses) SearchWebhookRequestsWithBodyWithResponse(ctx context.Context, id WebhookIdParameter, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SearchWebhookRequestsResponse, error) {
	rsp, err := c.SearchWebhookRequestsWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWebhookRequestsResponse(rsp)
}

func (c *ClientWithResponses) SearchWebhookRequestsWithResponse(ctx context.Context, id WebhookIdParameter, body SearchWebhookRequestsJSONRequestBody, reqEditors ...RequestEditorFn) (*SearchWebhookRequestsResponse, error) {
	rsp, err := c.SearchWebhookRequests(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchWebhookRequestsResponse(rsp)
}

// StreamWebhookRequestsWithResponse request returning *StreamWebhookRequestsResponse
func (c *ClientWithResponses) StreamWebhookRequestsWithResponse(ctx context.Context, id WebhookIdParameter, params *StreamWebhookRequestsParams, reqEditors ...RequestEditorFn) (*StreamWebhookRequestsResponse, error) {
	rsp, err := c.StreamWebhookRequests(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseStreamWebhookRequestsResponse(rsp)
}

// ParseListCollectionsResponse parses an HTTP response from a ListCollectionsWithResponse call
func ParseListCollectionsResponse(rsp *http.Response) (*ListCollectionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListCollectionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateCollectionResponse parses an HTTP response from a CreateCollectionWithResponse call
func ParseCreateCollectionResponse(rsp *http.Response) (*CreateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseImportFromOpenAPIResponse parses an HTTP response from a ImportFromOpenAPIWithResponse call
func ParseImportFromOpenAPIResponse(rsp *http.Response) (*ImportFromOpenAPIResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ImportFromOpenAPIResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest OpenAPIImportResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseDeleteFolderResponse parses an HTTP response from a DeleteFolderWithResponse call
func ParseDeleteFolderResponse(rsp *http.Response) (*DeleteFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateFolderResponse parses an HTTP response from a UpdateFolderWithResponse call
func ParseUpdateFolderResponse(rsp *http.Response) (*UpdateFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionFolder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRequestResponse parses an HTTP response from a DeleteRequestWithResponse call
func ParseDeleteRequestResponse(rsp *http.Response) (*DeleteRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateRequestResponse parses an HTTP response from a UpdateRequestWithResponse call
func ParseUpdateRequestResponse(rsp *http.Response) (*UpdateRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CollectionRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteCollectionResponse parses an HTTP response from a DeleteCollectionWithResponse call
func ParseDeleteCollectionResponse(rsp *http.Response) (*DeleteCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetCollectionResponse parses an HTTP response from a GetCollectionWithResponse call
func ParseGetCollectionResponse(rsp *http.Response) (*GetCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateCollectionResponse parses an HTTP response from a UpdateCollectionWithResponse call
func ParseUpdateCollectionResponse(rsp *http.Response) (*UpdateCollectionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateCollectionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Collection
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddFolderResponse parses an HTTP response from a AddFolderWithResponse call
func ParseAddFolderResponse(rsp *http.Response) (*AddFolderResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddFolderResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CollectionFolder
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAddRequestResponse parses an HTTP response from a AddRequestWithResponse call
func ParseAddRequestResponse(rsp *http.Response) (*AddRequestResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AddRequestResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest CollectionRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListFlowsResponse parses an HTTP response from a ListFlowsWithResponse call
func ParseListFlowsResponse(rsp *http.Response) (*ListFlowsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseCreateFlowResponse parses an HTTP response from a CreateFlowWithResponse call
func ParseCreateFlowResponse(rsp *http.Response) (*CreateFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetExecutionResponse parses an HTTP response from a GetExecutionWithResponse call
func ParseGetExecutionResponse(rsp *http.Response) (*GetExecutionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExecutionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowExecution
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetExecutionNodeResultsResponse parses an HTTP response from a GetExecutionNodeResultsWithResponse call
func ParseGetExecutionNodeResultsResponse(rsp *http.Response) (*GetExecutionNodeResultsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetExecutionNodeResultsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NodeExecutionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetNodeExecutionResultResponse parses an HTTP response from a GetNodeExecutionResultWithResponse call
func ParseGetNodeExecutionResultResponse(rsp *http.Response) (*GetNodeExecutionResultResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodeExecutionResultResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodeExecutionResult
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetNodeExecutionHistoryResponse parses an HTTP response from a GetNodeExecutionHistoryWithResponse call
func ParseGetNodeExecutionHistoryResponse(rsp *http.Response) (*GetNodeExecutionHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNodeExecutionHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest NodeExecutionHistoryResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteFlowResponse parses an HTTP response from a DeleteFlowWithResponse call
func ParseDeleteFlowResponse(rsp *http.Response) (*DeleteFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetFlowResponse parses an HTTP response from a GetFlowWithResponse call
func ParseGetFlowResponse(rsp *http.Response) (*GetFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateFlowResponse parses an HTTP response from a UpdateFlowWithResponse call
func ParseUpdateFlowResponse(rsp *http.Response) (*UpdateFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Flow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteFlowEnvironmentResponse parses an HTTP response from a DeleteFlowEnvironmentWithResponse call
func ParseDeleteFlowEnvironmentResponse(rsp *http.Response) (*DeleteFlowEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFlowEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetFlowEnvironmentResponse parses an HTTP response from a GetFlowEnvironmentWithResponse call
func ParseGetFlowEnvironmentResponse(rsp *http.Response) (*GetFlowEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFlowEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateOrUpdateFlowEnvironmentResponse parses an HTTP response from a CreateOrUpdateFlowEnvironmentWithResponse call
func ParseCreateOrUpdateFlowEnvironmentResponse(rsp *http.Response) (*CreateOrUpdateFlowEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateOrUpdateFlowEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUpdateFlowEnvironmentResponse parses an HTTP response from a UpdateFlowEnvironmentWithResponse call
func ParseUpdateFlowEnvironmentResponse(rsp *http.Response) (*UpdateFlowEnvironmentResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateFlowEnvironmentResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Environment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseListFlowExecutionsResponse parses an HTTP response from a ListFlowExecutionsWithResponse call
func ParseListFlowExecutionsResponse(rsp *http.Response) (*ListFlowExecutionsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListFlowExecutionsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest FlowExecutionListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseExportFlowResponse parses an HTTP response from a ExportFlowWithResponse call
func ParseExportFlowResponse(rsp *http.Response) (*ExportFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExportFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ExportedFlow
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest InternalServerError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseLaunchFlowResponse parses an HTTP response from a LaunchFlowWithResponse call
func ParseLaunchFlowResponse(rsp *http.Response) (*LaunchFlowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &LaunchFlowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ApiErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseHealthCheckResponse parses an HTTP response from a HealthCheckWithResponse call
func ParseHealthCheckResponse(rsp *http.Response) (*HealthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &HealthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Status string `json:"status"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListNodesResponse parses an HTTP response from a ListNodesWithResponse call
func ParseListNodesResponse(rsp *http.Response) (*ListNodesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListNodesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []NodeDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseListOperationsResponse parses an HTTP response from a ListOperationsWithResponse call
func ParseListOperationsResponse(rsp *http.Response) (*ListOperationsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ListOperationsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []OperationDefinition
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseReceiveWebhookDeleteResponse parses an HTTP response from a ReceiveWebhookDeleteWithResponse call
func ParseReceiveWebhookDeleteResponse(rsp *http.Response) (*ReceiveWebhookDeleteResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveWebhookDeleteResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReceiveWebhookGetResponse parses an HTTP response from a ReceiveWebhookGetWithResponse call
func ParseReceiveWebhookGetResponse(rsp *http.Response) (*ReceiveWebhookGetResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveWebhookGetResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReceiveWebhookPatchResponse parses an HTTP response from a ReceiveWebhookPatchWithResponse call
func ParseReceiveWebhookPatchResponse(rsp *http.Response) (*ReceiveWebhookPatchResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveWebhookPatchResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReceiveWebhookPostResponse parses an HTTP response from a ReceiveWebhookPostWithResponse call
func ParseReceiveWebhookPostResponse(rsp *http.Response) (*ReceiveWebhookPostResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveWebhookPostResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseReceiveWebhookPutResponse parses an HTTP response from a ReceiveWebhookPutWithResponse call
func ParseReceiveWebhookPutResponse(rsp *http.Response) (*ReceiveWebhookPutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReceiveWebhookPutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCreateWebhookResponse parses an HTTP response from a CreateWebhookWithResponse call
func ParseCreateWebhookResponse(rsp *http.Response) (*CreateWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 409:
		var dest Conflict
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON409 = &dest

	}

	return response, nil
}

// ParseDeleteWebhookResponse parses an HTTP response from a DeleteWebhookWithResponse call
func ParseDeleteWebhookResponse(rsp *http.Response) (*DeleteWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetWebhookResponse parses an HTTP response from a GetWebhookWithResponse call
func ParseGetWebhookResponse(rsp *http.Response) (*GetWebhookResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Webhook
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWebhookMethodDistributionResponse parses an HTTP response from a GetWebhookMethodDistributionWithResponse call
func ParseGetWebhookMethodDistributionResponse(rsp *http.Response) (*GetWebhookMethodDistributionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookMethodDistributionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MethodDistributionResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetWebhookRequestVolumesResponse parses an HTTP response from a GetWebhookRequestVolumesWithResponse call
func ParseGetWebhookRequestVolumesResponse(rsp *http.Response) (*GetWebhookRequestVolumesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetWebhookRequestVolumesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RequestVolumesResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseSearchWebhookRequestsResponse parses an HTTP response from a SearchWebhookRequestsWithResponse call
func ParseSearchWebhookRequestsResponse(rsp *http.Response) (*SearchWebhookRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchWebhookRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebhookRequestListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseStreamWebhookRequestsResponse parses an HTTP response from a StreamWebhookRequestsWithResponse call
func ParseStreamWebhookRequestsResponse(rsp *http.Response) (*StreamWebhookRequestsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &StreamWebhookRequestsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}
